<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[backbone-helloword 入门简单实例]]></title>
      <url>%2F2016%2F12%2F30%2Fbackbone-helloword%2F</url>
      <content type="text"><![CDATA[Backbone 简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js提供了一套web开发的框架，通过Models进行key-value绑定及custom事件处理,通过Collections提供一套丰富的API用于枚举功能,通过Views来进行事件处理及与现有的Application通过RESTful JSON接口进行交互.它是基于jquery和underscore的一个js框架。 主要组成 Model：创建数据模型，进行数据验证、销毁或者保存。 collection：model 的集合类。可以增加元素，删除元素，获取长度，排序，比较等一系列工具方法。 view：绑定 html 模板，绑定页面元素的时间，初始的渲染，模型值改变后的重新渲染和界面元素的销毁等。 Router：是对路由的处理，就像传统网站通过url现实不同的页面，在单页面应用（SPA）中通过Router来控制前面说的View的展示。 中文 API 网址：http://www.css88.com/doc/backbone/ Backbone 源码：https://github.com/jashkenas/backbone/ Backbone.js入门教程第二版：http://www.kancloud.cn/kancloud/backbonejs-learning-note underscore.js中文文档：http://www.css88.com/doc/underscore/ HelloWorld 简单 Demo 实例加入相关 JS&lt;script type=&quot;text/javascript&quot; src=&quot;../jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../underscore.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../backbone.js&quot;&gt;&lt;/script&gt; JS 说明 jquery-1.8.3.js：jQuery 相关，非必须。 underscore.js：Backbone 的唯一重度依赖 js。提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 backbone.js：这个自然为 backbone 的核心 js。 js 加入顺序就按我的来就行。 js 代码&lt;script type=&quot;text/javascript&quot;&gt; $(function(){ // 创建一个 World 模型 var Word = Backbone.Model.extend({ defaults:{ context:&quot;没什么想说的！&quot; } }); //创建一个 World 集合 var Words = Backbone.Collection.extend({ modle:Word //指定集合中的 model }); var words = new Words; //创建整个 body 视图 var AppView = Backbone.View.extend({ el:$(&quot;body&quot;), events:{ &quot;click #say&quot;:&quot;say&quot; //为 id=&quot;say&quot; 的按钮绑定单击事件 }, //初始化 initialize: function () { this.input = $(&quot;#context&quot;); //监听器 对 words 集合的 add 事件监听，回调函数 addWord this.listenTo(words,&quot;add&quot;,this.addWord); }, //对应上面 say say:function(){ var s = this.input.val(); var word; if (s == &quot;&quot;) { word = new Word; }else{ word = new Word({context:s}); } words.add(word); this.input.val(&quot;&quot;); }, //对应上面的 addWord addWord:function(model){ $(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot; + model.get(&quot;context&quot;) + &quot;&lt;/li&gt;&quot;); } }); //创建视图实例 var appView = new AppView; }) &lt;/script&gt; 这个简单的 helloworld 实例，涉及到 Model、Collection、View，每发送一句话代表就创建一个 model，并将这句话加入 collection 集合中，“add” 事件触发 addWord 方法，在 id 为 list 的ul 中加入一个 li 标签。 helloworld 结束语backbone 讲传统的 js mvc化，即模型、控制、视图分开开来，使前端与 server 的交互变得简单。有此优点：根据模型的变更自动更新应用程序的 HTML，有助于代码维护，同时促进客户端模块的使用，避免了在 JavaScript 中嵌套 Html 代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“单例”]]></title>
      <url>%2F2016%2F12%2F25%2Fjava_singleton%2F</url>
      <content type="text"><![CDATA[Java 单例概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式应该算是 23 种设计模式中最简单的一种模式了。所谓“单例”：就是一个类只有一个实例。因此，单例模式有以下三个要素： 私有构造方法 指向自己实例的私有静态引用 一个返回自己实例的公有方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式根据对象实例化时机分为两种：饿汉式与懒汉式。饿汉式：类在加载时就实例化一个对象；懒汉式：使用时实例化。 单例的实现饿汉式单例package com.wenka.singleton; public class Person1 { private final static Person1 PERSON1 = new Person1(); private Person1() { } public static Person1 getInstance() { return PERSON1; } } 懒汉式单例（一）package com.wenka.singleton; public class Person2 { private static Person2 person2; private Person2() { } public synchronized static Person2 getInstance() { if (person2 == null) { person2 = new Person2(); } return person2; } } 简要说明synchronized：将获取单例类实例的方法原子性、不可分割，有效避免了在多线程情况下出现创建不同对象的情况。 懒汉式单例（二）package com.wenka.singleton; public class Person3 { private static Person3 person; private Person3() { } public static Person3 getInstance() { if (person == null) { synchronized (Person3.class) { if (person == null) { person = new Person3(); } } } return person; } } 简要说明相比第一种懒汉式单例的方法，此次将 synchronized 同步代码块放入方法内容，这样只有在第一次创建到单例对象的时候，才会获取对象锁。一旦单例对象存在，将不用再如（一）一般每次获取单例对象都要进行获取锁，释放锁，大大提高了运行效率。 单例的优点 在内存中只创建了一个对象，节省了内存空间。 避免了频繁的创建、销毁对象。 避免对共享资源的多重占用。 全局访问。 结尾单例模式使用的场景：频繁的创建销毁对象，有状态的工具类对象。但是需要注意的是：不能使用反射创建单例对象，将会得到不同的对象。 本文源码：https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“线程”]]></title>
      <url>%2F2016%2F12%2F24%2Fjava_thread%2F</url>
      <content type="text"><![CDATA[Java 线程线程概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。 创建新执行线程有两种方法： 一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。 创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。 线程的创建java.lang.Thread 类的构造方法Thread() //① 分配新的 Thread 对象 Thread(Runnable target) //② 参数为：实现 Runnable 接口的类 Thread(Runnable target, String name) //③ 如②，并为此线程命名。 Thread(String name) //如① ,并为线程命名。 方法一：继承 Thread 类。class Thread1 extends Thread{ @Override public void run() { for(int i = 0; i &lt; 10; i++){ System.out.println(i + &quot; ---&gt;Thread&quot;); } } } 线程启动：调用构造方法① Thread1 thread1 = new Thread1(); thread1.start(); 方法二：实现 Runnable 接口。class Target implements Runnable{ @Override public void run() { for(int i = 0; i &lt; 10; i++){ System.out.println(i + &quot; ---&gt;target&quot;); } } } 线程启动：调用构造方法② Target target = new Target(); new Thread(target).start(); 线程常用方法Thread.currentThread()：获取当前线程 start()：启动线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 sleep()：睡眠。定时。 join()： 等待该线程终止。 线程之间的通信（一）：生产者消费者问题问题表述仓库类 Products： 描述仓库库存大小，及储存商品。 线程 Producter 表示生产者：生产产品，并放入仓库中，每次生产一件商品。若商品数量达到仓库库存大小时，生产等待;若商品数量小于仓库库存时，则继续生产。 线程 Consumer 表示消费者： 购买商品。每次购买一件商品。若库存为 0 时，停止购买，消费等待;若仓库存在商品，则继续购买。 编码声明仓库类class Products{ static int maxSize = 10;//仓库大小 static Queue&lt;Integer&gt; products = new LinkedList&lt;Integer&gt;(); //产品队列 } 生产者线程//生产者 class Producter extends Thread{ @Override public void run() { int i = 0; while (true) { synchronized (Products.class) { while (Products.products.size() == Products.maxSize) { System.out.println(&quot;仓库已经满了&quot;); try { Products.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;生产出来的产品编号：&quot; + i); Products.products.add(i); i++; Products.class.notifyAll(); } } } } 消费者线程//消费者 class Consumer extends Thread{ @Override public void run() { while (true) { synchronized (Products.class) { while (Products.products.isEmpty()) { System.out.println(&quot;仓库为空&quot;); try { Products.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +&quot;消费的产品编号 : &quot; + Products.products.remove()); Products.class.notifyAll(); //唤醒生产者线程生产产品 } } } } 测试 编写 Main 方法public class MainTest { public static void main(String[] args) { Producter producter = new Producter(); Consumer consumer = new Consumer(); producter.setName(&quot;Products-----&gt;&quot;); consumer.setName(&quot;Consumer-----&gt;&quot;); producter.start(); consumer.start(); } } 代码详解 synchronized 关键字：同步代码块，原子操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized 来给对象和方法或者代码块加锁，当它为一个方法或者一个代码块加锁的时候，只能有一个线程执行这段代码。当两个并发线程访问同一个对象的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后，释放锁，才能执行该代码块。 wait() 方法：线程等待 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前对象必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于某一个参数的版本，实现中断和虚假唤醒是可能的，而且此方法应始终在循环中使用 notifyAll() 方法：唤醒 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。 线程之间的通信（二）：多线程顺序打印“ABC”问题描述 线程A 负责打印“A”； 线程B 负责打印“B”； 线程C 负责打印“C”。 编码公用类class PrintABC { static Integer flag = 1; static void printA() { System.out.println(&quot;A&quot;); } static void printB() { System.out.println(&quot;B&quot;); } static void printC() { System.out.println(&quot;C&quot;); } } A线程// 打印 A class ThreadA extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 1) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printA(); PrintABC.flag = 2; PrintABC.class.notifyAll(); } } } } B线程// 打印 B class ThreadB extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 2) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printB(); PrintABC.flag = 3; PrintABC.class.notifyAll(); } } } } C线程//打印 C class ThreadC extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 3) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printC(); PrintABC.flag = 1; PrintABC.class.notifyAll(); } } } } 测试 Main 方法public class MainClass { public static void main(String[] args) { new ThreadA().start(); new ThreadB().start(); new ThreadC().start(); } } 总结本文对 Java 多线程的通信进行了简单的描述，欢迎对此文的补充。代码：https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“反射”]]></title>
      <url>%2F2016%2F12%2F23%2Fjava_reflect%2F</url>
      <content type="text"><![CDATA[java反射1、什么是反射？JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。 2、反射用来干什么？判断任意一个对象所属的类；调用其构造方法构造类的实例；获取、操作任意一个类所具 有的成员变量和方法；在运行时调用任意一个对象的方法等。 3、怎么用呢？首先我们先创建一个普通的 Demo 类。 12345package com.wenka.reflect;public class Demo &#123; public Demo() &#123; &#125; &#125; ####3.1 获取 Class三种方式获取 Class 对象： 123Class&lt;?&gt; demo1 = null;Class&lt;?&gt; demo2 = null;Class&lt;?&gt; demo3 = null; ① 通过 Class 类的静态方法 forName(String className)，参数为需要获取 Class 的类的全类名。 1demo1 = Class.forName(&quot;com.wenka.reflect.Demo&quot;); 注意：这里 ClassNotFoundException 异常需要处理，由于我们只是测试用，所以在这里选择上抛。 -② 从此类的实例中获取 1demo2 = new Demo().getClass(); -② 从类名中获取 1demo3 = Demo.class; -输出结果： 123demo1：class com.wenka.reflect.Demodemo2：class com.wenka.reflect.Demodemo3：class com.wenka.reflect.Demo ####3.2 获取到 Class 有什么用呢？？相信对于初学者也如当初的我一样，不知道接下来能干什么？这时，我们看一下 JavaAPI：java.lang.Class&lt;T&gt; 这个类。没错，我们可以通过它获取各种方法、各种属性等。 ① 在此之前先创建一个 Person 类方便测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.wenka.reflect;public class Person &#123; //两个私有属性 private String name; private Integer age; //两个私有属性的 getter/setter 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; //重写 toString() 方法输出测试。 @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; //写了四个构造方法：一个两参的，一个public一参的，一个private一参的，一个无参的。 public Person(String name, Integer age) &#123; super(); this.name = name; this.age = age; &#125; public Person(String name) &#123; this(name, 20); &#125; @SuppressWarnings(&quot;unused&quot;) private Person(Integer age) &#123; this(&quot;zhangsan&quot;, age); &#125; public Person() &#123; &#125; //两个私有方法：有参 work(int hours)、 无参 salary() @SuppressWarnings(&quot;unused&quot;) private void work(int hours) &#123; System.out.println(name + &quot;工作了&quot; + hours + &quot;个小时&quot;); &#125; @SuppressWarnings(&quot;unused&quot;) private double salary() &#123; return 5000; &#125;&#125; ② 获取构造方法 获取 Class 1Class&lt;?&gt; demo = Class.forName(&quot;com.wenka.reflect.Person&quot;); - 通过 API 发现有两个获取所有构造参数的方法。 getConstructors() 和 getDeclaredConstructors()通过对比发现：getConstructors()：不能获取到类的私有构造方法，而 getDeclaredConstructors() 则可以获取到所有的构造方法。 - 获取到指定的构造方法： - getConstructor(Class&lt;*?*&gt;... parameterTypes) 和 getConstructor(Class&lt;*?*&gt;... parameterTypes) 参数列表为想要的获取的那个构造方法所对应的参数列表楼主在此获取得到 public 参数列表为 String 的构造方法。通过调用 Constructor&lt;T&gt; 中的 newInstance(Object… initargs) 方法创建实例。此方法的参数列表就是对应的构造方法的参数列表的实参。 `Person person = (Person) demo.getConstructor(String.class).newInstance(&quot;wangwu&quot;); ` - 在此就有了疑问，既然我们可以通过 getDeclaredConstructor(Class&lt;*?*&gt;... parameterTypes) 获取到 **私有**的方法，那我们是不是也能通过此种办法，使得我们可以利用私有**构造方法**来创建实例？ `Constructor&lt;?&gt; constructor = demo.getDeclaredConstructor(Integer.class);` 没错，我们通过此方法获取到了私有构造方法，但是我们直接通过此创建实例会有异常： 1java.lang.IllegalAccessException: Class com.wenka.reflect.MainClass can not access a member of class com.wenka.reflect.Person with modifiers &quot;private&quot; 意思是说：这个构造方法是 “private”的，我们不能访问。但是，不要灰心，自习看了一下 Constructor&lt;*T*&gt; 类，Field、Method 和 Constructor 对象的基类为 **AccessibleObject** 类，这个类是干什么呢？ **它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。**哦，原来这个类可以取消 Java 语言的访问控制检查的能力啊。这就好办了。我们讲刚得到的私有构造方法 调用 setAccessible(boolean flag) 方法。将此方法设置为 false，使其取消反射的对象实施 Java 语言访问检查。 1constructor.setAccessible(true); 到此： 12Object newInstance = constructor.newInstance(20);System.out.println(newInstance); 输出： 1Person [name=zhangsan, age=20] 如果只能通过无参的构造方法来创建实例就比较简单了：当然前提是一定要有无参构造。 1234Person person = (Person) Demo.newInstance(); person.setAge(20); person.setName(&quot;A&quot;); System.out.println(person); ③ 获取字段 获取所有字段，与获取构造方法类似。调用 getDeclaredFields() 或者 getFields() 获取指定字段并赋值。getDeclaredField(String name) 参数：字段名。 12Field field = demo.getDeclaredField(&quot;age&quot;);field.setAccessible(true); 为字段设置新值： 1234Person person = new Person(&quot;AAAAAA&quot;);//field.set(obj, value);给 obj 对象的此属性设置 value 新值field.set(person, 100);System.out.println(person) ④ 获取方法 获取所有方法：getMethods()和 getDeclaredMethods(); 获取指定的方法：（在此依旧是获取 private 的方法，其它方法类似。） 当初我们创建的实体类中有 两个私有方法：有参 work(int hours)、 无参 salary() getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：参数列表为：1.方法名，2. 对应方法的参数列表的类型，0个 或者 多个。 123456Method work = demo.getDeclaredMethod(&quot;work&quot;, int.class); System.out.println(work);work.setAccessible(true);Person person = new Person(&quot;AAAA&quot;);// invoke(Object obj, Object... args) work.invoke(person, 10); 输出结果： 12private void com.wenka.reflect.Person.work(int)AAAA工作了10个小时 Method 类中的 invoke(Object obj, Object… args) 方法，对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 参数：1.指定对象 2.对应参数列表的实参。 倘若方法有返回值，则直接返回： Method salary = demo.getDeclaredMethod(&quot;salary&quot;); salary.setAccessible(true); Object invoke = salary.invoke(person); System.out.println(&quot;得到了工资：&quot; + invoke); 结果为： 1得到了工资：5000.0 致此：反射的简单用法都已经写完了，可以发现，反射很强大的，我们甚至可以通过反射使 单例 不再单例，通过反射获取注释，接口等关于此类的所有信息，并从底层操作。未来学习的框架都运用了反射的原理来实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
