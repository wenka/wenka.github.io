<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[SQL命令之CRUD操作]]></title>
      <url>%2F2017%2F02%2F05%2Fsql-CRUD%2F</url>
      <content type="text"><![CDATA[1 前言&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于简单的数据库来说，无非就是 CRUD 操作。本文只对简单的 CRUD 命令进行综述。 1.1 关于数据库命名的那些事 SQL 语对英文大小不敏感。 表名/数据库名/列名：统一大小写（不要既有大写又有小写）。若存在多个单词，使用下划线[ _ ]分割。 虽说 SQL 对大小写不敏感，但是在使用第三方工具对 ORACLE 数据库操作的情况下，建议使用 大写。[本人入过坑，其它数据库暂没出现问题] 2 “ C “ 操作2.1 创建数据库-- 创建数据库 CREATE DATABASE db_name -- 使用数据库 use db_name 2.2 创建表-- 创建表 CREATE TABLE table_name( column_name_1 data_type [constraint]， column_name_2 data_type [constraint]， ...... ) 注： column_name：列名 date_type：数据类型 constraint：约束 2.3 插入数据-- 向 &apos;table_name&apos; 表中插入数据 INSERT INTO table_name VALUES (value1,value2...) 注：value1,value2… 等值的顺序要与表中对应的列保持一致。 -- 向 &apos;table_name&apos; 中的某些列插入数据 其它列为默认数据 INSERT INTO table_name (column1,column2...) VALUES (value1,value2...) 注：value值要与column列一一对应。 3 “U” 操作3.1 UPDATE：修改表中的数据。-- 更新表中某列的数据 UPDATE table_name SET column_name1=new_value1 [,column_name2=new_value2...] [WHERE ....] 3.2 ALTER：修改表3.2.1 为表中添加列ALTER TABLE table_name ADD new_column_name data_type 3.2.2 删除表中的列ALTER TABLE table_name DROP COLUMN column_name 3.3.3 修改表中的列的数据类型-- SQLSERVER / MS ACCESS 数据库 ALTER TABLE tabl_name ALTER COLUMN column_name new_date_type -- MYSQL / ORACLE 数据库 ALTER TABLE table_name MODIFY COLUMN column_name new_data_type 4 “D” 操作4.1 DELETE 旨在删除表中的数据。 DELETE FROM table_name [WHERE condition...[条件]] 4.2 DROP 删除表、数据库、索引 -- 删除表 DROP TABLE table_name -- 删除数据库 DROP DATABASE db_name 注： 对于不同的数据库删除索引的方式不一样 参考：http://www.runoob.com/sql/sql-drop.html 4.2 TRUNCATE 清空表（不删除表的结构，只删除其中的数据） -- 清空表 TRUNCATE TABLE table_name 5 “R” 操作5.1 单表查询12SELECT column1,column2... FROM table_name[WHERE [contion...]] 注： 若查询所有的列，可使用 * 表示。 5.2 多表查询表1：t1 id | name -----+------ 1 | a 2 | b 3 | c 表2：t2 id | value -----+------- 1 | xxx 3 | yyy 5 | zzz 5.2.1 JOIN / INNER JOIN把多张表中的行结合起来，基于这些表之间的共同字段。返回满足 JOIN 条件的所有行。 SELECT * FROM t1 INNER JOIN t2 ON t1.id=t2.id -- 结果： id | name | value -----+------+------- 1 | a | xxx 3 | c | yyy 5.2.2 LEFT JOIN返回表1的全部数据，以及匹配表1的表2中的数据。若表1中有未匹配项，则补充空值。 SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id -- 结果： id | name | id | value -----+------+-----+------- 1 | a | 1 | xxx 2 | b | | 3 | c | 3 | yyy 5.2.3 RIGHT JOIN返回表2的全部数据，以及匹配表2的表1中的数据。若表2中有未匹配项，则补充空值。 SELECT * FROM t1 RIGHT JOIN t2 ON t1.id=t2.id -- 结果： id | name | id | value -----+------+-----+------- 1 | a | 1 | xxx 3 | c | 3 | yyy | | 5 | zzz 6 结束语此文介绍了 SQL 中简单的 CRUD 操作。若有补充，请 –留言– （本人愚钝，请多指教！2017/2/5 10:54:45 ）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[gradle入门使用]]></title>
      <url>%2F2017%2F01%2F20%2Fgradle%2F</url>
      <content type="text"><![CDATA[一：加入插件apply plugin: &apos;java&apos; Java 插件加入了很多的任务： assemble任务会编译程序中的源代码，并打包生成Jar文件，这个任务不执行单元测试。 build任务会执行一个完整的项目构建。 clean任务会删除构建目录。 compileJava任务会编译程序中的源代码。 ` apply plugin: &apos;maven&apos; ` 二：命令gradle tasks ： 得到一个可运行任务及其描述的完整的列表。 gradle assemble ：打包项目。仅仅执行项目打包所必须的任务集。 gradle build ：打包项目。打包项目所必须的任务集，以及执行自动化测试。 gradle test ：执行测试。 gradle war ：打包 war 文件。 三：build.gradle文件使用一个包含键值对的map结构指定加入到manifest文件的属性集。 jar { manifest { attributes &apos;Main-Class&apos;:&apos;com.wenka.gradle.HelloWorld&apos; //指定jar包的main文件。 } } 四：在构建中加入 Maven 仓库 通过 URL 添加一个 Maven 仓库 repositories { maven { url &quot;http://maven.petrikainulainen.net/repo&quot; } } 通过本地文件系统地址添加一个 Maven 仓库 repositories { maven { url &amp;quot;../maven-repo&amp;quot; } } 在加入Maven仓库时，Gradle提供了三种“别名”供我们使用，它们分别是： mavenCentral()别名，表示依赖是从Central Maven 2 仓库中获取的。 jcenter()别名，表示依赖是从Bintary’s JCenter Maven 仓库中获取的。 mavenLocal()别名，表示依赖是从本地的Maven仓库中获取的。 如： repositories { mavenCentral() } 五：依赖管理简介java 插件指定了若干以来配置项 当项目的源代码被编译时，compile配置项中的依赖是必须的。 runtime配置项中包含的依赖在运行时是必须的。 testCompile配置项中包含的依赖在编译项目的测试代码时是必须的。 testRuntime配置项中包含的依赖在运行测试代码时是必须的。 archives配置项中包含项目生成的文件（如Jar文件）。 default配置项中包含运行时必须的依赖。 声明项目依赖：group属性指定依赖的分组（在Maven中，就是groupId）。 name属性指定依赖的名称（在Maven中，就是artifactId）。 version属性指定外部依赖的版本（在Maven中，就是version） 例如： dependencies { compile &apos;mysql:mysql-connector-java:5.1.24&apos; compile group:&apos;mysql&apos;,name:&apos;mysql-connector-java&apos;,version:&apos;5.1.24&apos; } 六：多项目构建–&gt;模块简介# 包含哪些项目 include &apos;app&apos; include &apos;core&apos; - subprojects { //configuration 通用的配置 } - allprojects{ //configuration 共享的配置 }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>%2F2017%2F01%2F20%2Fgit%2F</url>
      <content type="text"><![CDATA[GIT 常用命令git官网：：https://git-scm.com/downloads下载对应的版本。 借鉴：http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html git简易使用指南：http://www.bootcss.com/p/git-guide/ 生成公钥$ ssh-keygen -t rsa -C “邮箱号” 然后回车回车….，其中让输入名字和密码，可以直接回车不输入。 最后在对应的文件夹下生成默认名字的两个文件：：id_rsa和id_rsa.pub 然后把 id_rsa.pub中的秘钥添加到远程仓库中。 配置全局 email 和 name$ git config --global user.name &quot;your name&quot; $ git config --global user.email &quot;your email&quot; 初始化仓库 clone 远程仓库。 # 首先关联远程仓库(例子：添加github远程仓库) $ git remote add origin git@github.com:用户名/仓库名.git git clone git@192.168.*.***:仓库名.git 若使用 github： git clone git@github.com:你的名字/仓库名.git 若远程仓库空无一物 则在本地初始化 git init 经过以上步骤，会发现本地的当前文件夹下多了个 .git 文件。 文件的提交1.查看变更的文件$ git status 2.将文件添加到本地暂存区$ git add . . ：代表当前目录下的所有文件 # 也可以是 git add &lt;file&gt; #添加某一个或者多个文件。 ``` 3.将暂存区的文件提交到本地仓库$ git commit -m [message] # 当然也可以是 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次 commit 之后的变化，直接到仓库区 $ git commit -a 4.将本地仓库提交的远程仓库$ git push origin master # 可以把 master 换成你想要推送的任何分支。 # 如果是使用的 git init 初始化仓库，第一次 push 使用： $ git push -u origin master 查看# 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 显示当前分支的最近几次提交 $ git reflog # 显示某次提交的元数据和内容变化 $ git show [commit] 更新# 下载远程仓库的所有变动 $ git fetch origin # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show origin # 取回远程仓库的变化，并与本地分支合并 $ git pull origin [branch] # 上传本地指定分支到远程仓库 $ git push origin [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push origin --force # 推送所有分支到远程仓库 $ git push origin --all 注：origin为远程仓库在本地的名字。 branch：分支 回退历史# 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash po # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2017%2F01%2F09%2Fjava_factory%2F</url>
      <content type="text"><![CDATA[创建型模式之“工厂模式”1. 工厂模式简述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。 2. 实例代码2.1 产品相关代码//产品接口 public interface IProduct { void productMethod(); } //产品实现 public class Product implements IProduct { @Override public void productMethod() { System.out.println(&quot;This is Product Method...&quot;); } } 2.2 工厂相关代码//工厂接口 public interface IProduct { void productMethod(); } //工厂实现 public class Product implements IProduct { @Override public void productMethod() { System.out.println(&quot;This is Product Method...&quot;); } } 3. 工厂模式的优点 可以使代码结果清晰，有效地封装变化。 降低耦合度。 3.1 工厂模式有四个要素： 产品接口：定义产品的规范。 产品实现：实现产品接口中具体类，决定产品在客户端的具体行为。 工厂接口：工厂方法的核心。规范工厂“产出”的产品。 工厂实现：决定如何实例化产品。 3.2 工厂模式的适用场景：工厂模式是解耦模式，如果需要增加类之间的依赖关系时，可以考虑适用工厂模式。或者当系统需要良好的扩展性的时候，也可以考虑工厂模式。 4. 实例2创建一个电脑类(Computer)：由显示器(LCD) 和 主机(Host)构成。 代码如下 //主机实现代码 public class Host implements IHost { @Override public void show() { System.out.println(&quot;This is Computer&apos;s Host...&quot;); } } //显示器实现代码 public class LCD implements ILCD { @Override public void show() { System.out.println(&quot;This is Computer&apos;s LCD...&quot;); } } //电脑实现代码 public class Computer implements IComputer{ private IHost host; private ILCD lcd; public Computer(IHost host, ILCD lcd){ this.host = host; this.lcd = lcd; } @Override public void show(){ host.show(); lcd.show(); } } 若不使用工厂模式： public class TestMain { public static void main(String[] args) { IHost host = new Host(); ILCD lcd = new LCD(); Computer computer = new Computer(host, lcd); computer.show(); } } 我们需要一个个创建实例，然后再组合成一个电脑。 使用工厂模式后： public class Factory implements IFactory { @Override public IComputer getComputer() { IHost host = new Host(); ILCD lcd = new LCD(); IComputer computer = new Computer(host, lcd); return computer; } } public class TestMain { public static void main(String[] args) { IFactory factory = new Factory(); IComputer computer = factory.getComputer(); computer.show(); } } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，我们不用关心电脑是怎么创建的，只在用到电脑的时候通过工厂创建出一个电脑。这样大大减少了耦合度，对于扩展性，如果我们电脑需要其他组件，再在工厂中增加相应的东西的就行了，对于客户端代码无需改动。此代码相比于之前的代码，灵活性和稳定性都得到了极大的提高。 本文源码： https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/factory https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/factory2 （本人愚钝，请多指教！2017/1/2 11:40:53 ）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring4笔记之IOC（二）]]></title>
      <url>%2F2017%2F01%2F02%2FSpring4-IOC2%2F</url>
      <content type="text"><![CDATA[1 Bean 之间的关系&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bean 之间的关系分为继承和依赖。Spring中如果两个Bean的配置信息大同小异，可采用继承的方式，子bean从父bean中继承部分配置。Spring可建立一个bean对其他bean的依赖关系，Spring负责管理这些Bean的关系，当实例化一个Bean时，Spring保证该Bean所依赖的其他Bean已经初始化。 1.1 bean 之间的继承关系&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;spring 中bean的继承和Java中的继承截然不同前者是对象和对象之间的关系，后者是类和类之间的关系。 Spring中的子bean和父bean可以是不同的类型，但是Java中的继承，子类是一种特殊的父类。 Spring中的bean的继承是实例之间的关系，而Java中的继承是类与类之间的关系。 Spring中子bean不可以作为父bean使用，不具备多态性，Java中的子类实例完全可以当作父类实例使用。 1.1.1 测试代码POJO： public class Address { private String city; private String street; ......(省略对应的 getter/setter 方法) } relation-beans.xml：（Spring的配置文件） &lt;bean id=&quot;address1&quot; p:city=&quot;ZhengZhou^^&quot; p:street=&quot;WenHuaRode&quot; abstract=&quot;true&quot; &gt;&lt;/bean&gt; &lt;bean id=&quot;address2&quot; class=&quot;com.spring.beans.relation.Address&quot; parent=&quot;address1&quot; &gt;&lt;/bean&gt; &lt;bean id=&quot;address3&quot; class=&quot;com.spring.beans.relation.Address&quot; p:street=&quot;JianXueJie&quot; parent=&quot;address2&quot; &gt;&lt;/bean&gt; 1.1.2 配置简述 abstract：指明当前 bean 为抽象bean。设置 abstract=”true” ，这样的bean不能被 IOC 容器创建实例，只用来作为继承的模板。 parent：指明继承自哪个 bean。 bean 之间的继承支持多重继承。 1.2 bean 之间的依赖关系依赖：Spring允许用户通过depends-on属性设定Bean前置依赖的Bean ，前置依赖的Bean会在本Bean实例化之前创建好。 1.2.1 测试代码Person类： public class Person { private String name; private int age; private Car car; private Address address; ......(省略对应的 getter/setter 方法) } Car类： public class Car { private String type; private double price; ......(省略对应的 getter/setter 方法) } relation-beans.xml：（Spring的配置文件） &lt;bean id=&quot;car&quot; class=&quot;com.spring.beans.relation.Car&quot; p:type=&quot;Audi&quot; p:price=&quot;300000&quot; &gt;&lt;/bean&gt; &lt;bean id=&quot;person&quot; class=&quot;com.spring.beans.relation.Person&quot; p:name=&quot;A&quot; p:age=&quot;18&quot; p:address-ref=&quot;address2&quot; p:car-ref=&quot;car&quot; depends-on=&quot;car&quot; &gt;&lt;/bean&gt; 2 bean 的生命周期Bean 的生命周期分为：初始化前，初始化后，销毁。 2.1 测试代码（先看代码，稍后详细说明） POJO：增加了 init 和 destory方法，分别表示初始化时，和销毁时的方法（方法名随意） public class Worker { private String name; public Worker() { super(); System.out.println(&quot;this is constructors...&quot;); } public String getName() { System.out.println(&quot;getName.....&quot;); return name; } public void setName(String name) { System.out.println(&quot;setName...&quot;); this.name = name; } public void init() { System.out.println(&quot;init.....&quot;); } public void destory() { System.out.println(&quot;destory...&quot;); } @Override public String toString() { return &quot;Worker [name=&quot; + name + &quot;]&quot;; } } bean 的后置处理器：实现 BeanPostProcessor 接口。 public class TestBeanPostProcessor implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(&quot;Before:&quot; + bean + &quot; --&gt; &quot; + beanName); // 通过此方法 对 bean 进行过滤 if (beanName.equals(&quot;worker&quot;)) { System.out.println(&quot;-------------------&quot;); } return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(&quot;After:&quot; + bean + &quot; --&gt; &quot; + beanName); return bean; } } Spring 配置文件： &lt;!-- 配置 bean --&gt; &lt;bean id=&quot;worker&quot; class=&quot;com.spring.beans.lifecycle.Worker&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot; &gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 bean 的后置处理器：不需要配置 id ，IOC 容器会自动识别是一 BeanPostProcessor --&gt; &lt;bean class=&quot;com.spring.beans.lifecycle.TestBeanPostProcessor&quot; &gt;&lt;/bean&gt; Test获取bean this is constructors... setName... Before:Worker [name=Tom] --&gt; worker ------------------- init..... After:Worker [name=Tom] --&gt; worker 一月 02, 2017 11:05:31 上午 org.springframework.context.support.ClassPathXmlApplicationContext doClose 信息: Closing org.springframework.context.support.ClassPathXmlApplicationContext@c4437c4: startup date [Mon Jan 02 11:05:31 GMT+08:00 2017]; root of context hierarchy destory... 2.2 代码详解 Worker类：增加了 init 和 destory方法，分别表示初始化时，和销毁时的方法（方法名随意） bean 的后置处理器：配置和初始化一个bean之后实现一些自定义逻辑回调方法。 postProcessBeforeInitialization(Object bean, String beanName)：bean 初始化之前被调用 postProcessAfterInitialization(Object bean, String beanName)：bean 初始化之后被调用 参数 &gt; bean ： bean 实例本身。 参数 &gt; beanname ：IOC 容器配置的 bean 的名字。 返回值：是实际上返回给用户的那个 Bean ，注意：可以在以上两个方法中修改返回的 bean ，甚至返回一个新的 bean 。 Spring配置文件中： &lt;bean id=&quot;worker&quot; class=&quot;com.spring.beans.lifecycle.Worker&quot; init-method=&quot;init&quot; destroy-method=&quot;destory&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot; &gt;&lt;/property&gt; &lt;/bean&gt; init-method：指明当前 bean 的初始化方法的方法名。 destroy-method：指明当前 bean 的销毁时方法的方法名。 Spring配置文件中： &lt;bean class=&quot;com.spring.beans.lifecycle.TestBeanPostProcessor&quot; &gt;&lt;/bean&gt; 配置bean的后置处理器。IOC 容器会自动识别是 BeanPostProcessor。 3 Bean 的作用域默认情况下，Spring应用上下文中所有 bean 都是作为单例的形式创建的。但是也有特殊情况下（Struts2中的Action）不是单例的。 Spring 定义了多种作用域： 单例（Singleton）：在整个应用中，只创建 bean 的一个实例。 原型（Prototype）：每次注入或者通过 Spring 上下文获取的时候，都会创建一个新的 bean 的实例。 会话（Session）：在 Web 应用中，为每个会话创建一个 bean 实例。 请求（Request）：在 Web 应用中，为每个请求创建一个 bean 实例。 用法： 在Spring配置文件中：直接在 &lt;bean&gt; 标签中加入 scope 属性，并指明属性值为哪个作用域。 注解中：使用 @Scope(“……”) 注解声明作用域。 4 使用 SPEL 装配 beanSPEL：Spring Expression Language，Spring表达式语言。使用 #{…..} 。 使用 bean 的 id 来引用 bean。 调用外部 类/bean 的属性。 对值进行算术、关系、逻辑运算。 正则表达式匹配。 集合操作。 例子： 调用外部类的静态属性： &lt;property name=&quot;cycle&quot; value=&quot;#{T(java.lang.Math).PI * 80}&quot;&gt;&lt;/property&gt; 三目运算： &lt;property name=&quot;info&quot; value=&quot;#{car.price &gt; 200000 ? &apos;白领&apos; : &apos;蓝领&apos;}&quot; &gt;&lt;/property&gt; 调用外部 bean 的属性： &lt;property name=&quot;city&quot; value=&quot;#{address.city}&quot; &gt;&lt;/property&gt; 小结本文主要讲解了 Bean之间的关系，依赖与继承，使得我们能够轻易处理实例之间的关系；通过对 bean 的生命周期的操作，我们可以在 bean 初始化前后对 bean 进行操作；Spring提供了四中 bean 的生命周期，可以在开发中选择适当的处理方式；最后使用 SEPL，在bean初始化时对属性的注入起到了很大的作用。 （本人愚钝，请多指教！2017/1/2 11:40:53 ）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring4笔记之IOC（一）]]></title>
      <url>%2F2017%2F01%2F01%2FSpring4-IOC%2F</url>
      <content type="text"><![CDATA[1 IOC(DI)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IOC：控制反转，亦成为DI（依赖注入）。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Spring应用中，应用对象生存与 Spring容器 中，Spring容器 负责创建对象，装配它们，配置它们并管理它们的生命周期。容器时 Spring 的核心，Spring 容器使用依赖注入管理构成应用的组件，创建相互协作的组件之间的关联。更多的我们通过应用上下文创建容器。 AnnotationConfigApplicationContext：从一个或者多个基于 Java 的配置类中加载 Spring 应用上下文。 AnnotationConfigWebApplicationContext：从一个或者多个基于 Java 的配置类中记载 Spring Web 应用上下文。 ClassPathXmlApplicationContext：从类路径下的一个或者多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。 FileSystemXmlApplicationContext：从文件系统下的一个或者多个 XML 配置文件中加载上下文定义。 XmlWebApplicationContext：从 Web 应用下的一个或者多个 XML 配置文件中记载上下文定义。 如下： // 创建 spring 的 IOC 容器 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 注意：创建 IOC 容器时，调用了对应 实体类的构造方法，和对应 属性 的 setter 方法。 2 Spring 装配 Bean2.1 在 XML 中显式配置applicationContext.xml： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; ...... &lt;/beans&gt; 要基于 XML 的 Spring 配置中声明一个 Bean，需要使用 spring-beans 模式的 &lt;bean&gt; 标签。 2.1.1 属性注入 创建一个实体类 User public class User { private String name; public User() { super(); System.out.println(&quot;构造方法......&quot;); } public String getName() { return name; } public void setName(String name) { System.out.println(&quot;setter......&quot;); this.name = name; } public void show(){ System.out.println(&quot;Name：&quot; + name); } } 在Spring配置文件装配 bean： id：bean的标识。 class：指向创建这个 bean 的类，使用全限定的类名。 &lt;property&gt;标签：将字面量注入到属性中。 name：指定哪个属性 value：值 从 IOC 容器中获取 bean User user = (User) context.getBean(&quot;user&quot;); user.show(); 2.1.2 构造器注入 创建实体类 public class Car { private String type; private String productPlace; private double price; private int speed; public Car() { super(); } public Car(String type, String productPlace, double price) { super(); this.type = type; this.productPlace = productPlace; this.price = price; } public Car(String type, String productPlace, int speed) { super(); this.type = type; this.productPlace = productPlace; this.speed = speed; } ......(省略对应的 getter/setter 方法) } Spring配置文件：使用 &lt;constructor-arg&gt;标签 &lt;bean id=&quot;car1&quot; class=&quot;com.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;300000&quot; index=&quot;2&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; index、value：指定在构造方法中的第几个参数的value值。 或者使用： &lt;bean id=&quot;car2&quot; class=&quot;com.spring.beans.Car&quot;&gt; &lt;constructor-arg value=&quot;Audi&quot;&gt;&lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;value&gt;&lt;![CDATA[&lt;shanghai&gt;]]&gt;&lt;/value&gt; &lt;/constructor-arg&gt; &lt;constructor-arg value=&quot;200&quot; type=&quot;int&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 2.1.3 bean 之间的引用创建 People 类： public class Person { private String name; private int age; private Car car; ......（省略对应的 getter/setter 方法） } People 中有 Car 类型的属性： &lt;bean id=&quot;person1&quot; class=&quot;com.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;property name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/property&gt; 中ref引用 id 为 car1 的bean。 还有一种方法，使用内部 bean ： &lt;bean id=&quot;person2&quot; class=&quot;com.spring.beans.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;car&quot;&gt; &lt;bean class=&quot;com.spring.beans.Car&quot;&gt; &lt;property name=&quot;type&quot; value=&quot;BaoMa&quot;&gt;&lt;/property&gt; &lt;property name=&quot;productPlace&quot; value=&quot;BeiJing&quot;&gt;&lt;/property&gt; &lt;property name=&quot;speed&quot; value=&quot;200&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;400000&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 但是需要注意：内部 bean 的引用 不能被其他 bean 引用。 2.1.4 注入List(Set)集合将 People 中的 car 改为集合类型 cars： public class People { private String name; private int age; private List&lt;Car&gt; cars; ......（省略构造方法及对应的 getter/setter 方法） } 内部装配直接在&lt;property&gt;中使用 &lt;list&gt; 标签： &lt;bean id=&quot;people3&quot; class=&quot;com.spring.beans.collection.People&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;car1&quot; /&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 使用外部装配 先定义外部 list （在这里需要加入spring-util 的 schemaL，使用&lt;util:list&gt;标签） &lt;util:list id=&quot;cars&quot;&gt; &lt;bean class=&quot;com.spring.beans.Car&quot;&gt; &lt;property name=&quot;type&quot; value=&quot;BaoMa&quot;&gt;&lt;/property&gt; &lt;property name=&quot;productPlace&quot; value=&quot;BeiJing&quot;&gt;&lt;/property&gt; &lt;property name=&quot;speed&quot; value=&quot;200&quot;&gt;&lt;/property&gt; &lt;property name=&quot;price&quot; value=&quot;400000&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;ref bean=&quot;car2&quot; /&gt; &lt;/util:list&gt; 引用外部 list &lt;bean id=&quot;people4&quot; class=&quot;com.spring.beans.collection.People&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot; ref=&quot;cars&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 2.1.5 注入Map集合将 People 类中的 List&lt;Car&gt; cars 改为 Map&lt;String, Car&gt; cars： public class NewPeople { private String name; private int age; private Map&lt;String, Car&gt; cars; ......（省略构造方法及对应的 getter/setter 方法） } 注入： &lt;bean id=&quot;people5&quot; class=&quot;com.spring.beans.collection.NewPeople&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt; &lt;property name=&quot;cars&quot;&gt; &lt;map&gt; &lt;entry key=&quot;Car___1&quot; value-ref=&quot;car1&quot; &gt;&lt;/entry&gt; &lt;entry key=&quot;Car___2&quot; value-ref=&quot;car2&quot; &gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; 2.2 基于注解方式Spring 从两个角度来实现自动化装配： 组件扫描：Spring 会自动发现应用上下文中所创建的 bean。 自动装配：Spring 自动满足 bean 之间的依赖。 2.2.1 自动装配（为什么先说自动装配呢？因为要是没装配，扫描谁啊！）首先认识类上的四个注解： @Component：表名该类会作为组件类，并告知 Spring 要为这个类创建 bean。当组件不好归类时，使用这个。 @Repository：用于标注数据访问组件，即DAO组件。 @Service：用于标注业务层组件。 @Controller：用于标注控制层组件。 @Autowired：默认按类型自动装配。 2.2.2 设置组自动扫描需要加入 context 命名空间。 &lt;context:component-scan base-package=&quot;com.spring&quot;&gt;&lt;/context:component-scan&gt; base-package：表名需要扫描的包。 3 结束语&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring的核心就是 Spring 容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足，这样才能完成业务功能。本人还是感觉基于注解方式配置bean比较方便些。 （——继续努力，请多多指教！2017/1/1 20:49:17 ）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Spring4笔记之 AOP]]></title>
      <url>%2F2017%2F01%2F01%2FSpring4-Aop%2F</url>
      <content type="text"><![CDATA[1 什么是面向切面编程（AOP）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先说一下横切关注点，散布于应用中多处的功能被成为横切关注点，往往会直接把横切关注点嵌入到应用的业务逻辑之中。而面向切面编程（AOP）的目的就是把这些横切关注点与业务逻辑相分离。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，切面实现了横切关注点的模块化。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用面向切面编程时，仍然需要在一个地方定义通用功能，但是可能通过声明的方式定义这个功能要以何种方式的何地使用，而无需修改受影响的类。横切关注点可以被模块化成特殊的类，这种类就是切面。 2 AOP 中的名词2.1 通知通知定义了切面是什么以及何时使用。 Spring 切面的五种通知： 前置通知（Before）：在目标方法被调用之前调用该通知功能。 后置通知（After）：在目标完成之后调用通知。并不关心方法的输出。 返回通知（After-returning）：在目标方法成功执行之后调用通知。 异常通知（After-throwing）：在目标方法抛出异常后调用用纸。 环绕通知（Around）：通知包含了被通知的方法，在被通知的方法调用之前和调用之后执行自定义行为。 2.2 连接点连接点是在应用执行过程中能够插入切面的一个点。这个点可以调用方法时，抛出异常时，甚至修改一个字段时。 2.3 切点切点会匹配通知所有植入的一个或多个连接点。 2.4 切面切面通知和切点的结合。 3 简单实例（使用注解方式）3.1 创建带有简单加减乘除的接口及其实现类package com.spring.aop.helloworld; public interface SimpleCalculator { double add(double num1, double num2); double sub(double num1, double num2); double mult(double num1, double num2); double div(double num1, double num2); } 目标：调用每个方法的时候获取方法名及参数列表。 如果不面向切面编程，我们就需要在每个方法的前后加入同样的代码来获取参数列表等，会产生大量的冗余代码。使用切面，将这些冗余代码提取出来，单独放入一个类中，使用方法的业务与其它功能分开来，有利于代码的简洁，提高代码的重用性，方便了后期的维护。 3.2 编写切面类@Component @Aspect public class LogginAspectj { ...... } @Component：首先将该类放入 IOC 容器中。 @Aspect：将此类声明为一个切面类。 3.3 编写通知@Before(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;) public void beforeMethod(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;); } // 后置通知 @After(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;) public void afterMethod(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;); } // 返回通知 //在【方法正常结束】执行的代码 //返回通知是可以接受返回值的 @AfterReturning(value = &quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;, returning = &quot;result&quot;) public void afterReturning(JoinPoint joinPoint, Object result) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result); } //异常通知 //在目标方法出现异常时会执行的代码 //可以访问到异常对象；且可以指定特定异常时再执行异常通知代码 @AfterThrowing(value = &quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;, throwing=&quot;e&quot;) public void afterThrowing(JoinPoint joinPoint,Exception e){ String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e); } 声明通知方法 @Before：前置通知 @After：后置通知 @Afterreturning：返回通知 @AfterThrowing：异常通知 通知注解中的参数 value 值：切面表达式。告知此通知的切点。 execution：在相关方法执行时触发。 ： 代表任意。第一个代表任意返回值，第二个代表com.spring.aop.helloworld.SimpleCalculator 此类下的任意方法。 (..)：代表使用任意参数。 returning：@AfterReturning通知后的返回值。 throwing：@AfterThrowing通知获取到的异常。 参数列表： JoinPoint：连接点。通过连接点joinPoint.getSignature().getName()可以获取激活此通知的方法名。通过joinPoint.getArgs()获取激活此通知的方法的参数列表。 Object：与@AfterReturning中的属性returning名一致。获取激活此通知的方法的返回值。 Exception：与@AfterThrowing中的属性throwing名一致。获取激活此通知的方法的异常信息。 3.4 通用的切点以上代码会发现，每个通知中的切点都一样，那既然都一样的话，那会不会有一种简单的方式，使我们只用写一次切面表达式而达到重用呢？答案肯定有。 //切面表达式 @Pointcut(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;) public void declarExpression(){} 使用@Pointcut声明此方法为一个切点。这样的话，所有的切面表达式都只需要替换成此方法的方法名即可。这样就省去了重复写那么长那么多的切面表达式的力气。 @Component @Aspect public class LogginAspectj { //切面表达式 @Pointcut(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;) public void declarExpression(){} // 声明该方法是一个前置通知：在目标方法执行之前执行 @Before(&quot;declarExpression()&quot;) public void beforeMethod(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;); } // 后置通知 @After(&quot;declarExpression()&quot;) public void afterMethod(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;); } // 返回通知 //在【方法正常结束】执行的代码 //返回通知是可以接受返回值的 @AfterReturning(value = &quot;declarExpression()&quot;, returning = &quot;result&quot;) public void afterReturning(JoinPoint joinPoint, Object result) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result); } //异常通知 //在目标方法出现异常时会执行的代码 //可以访问到异常对象；且可以指定特定异常时再执行异常通知代码 @AfterThrowing(value = &quot;declarExpression()&quot;, throwing=&quot;e&quot;) public void afterThrowing(JoinPoint joinPoint,Exception e){ String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e); } } 3.5 完结了吗？至此，此类仅仅是IOC中的一个普通bean，即使使用了@Aspect注解，但是它依旧不会被视为切面，这些注解不会被解析，也不会被转换为切面的代理。我们还有在Spring配置文件中加入Spring aop命名空间中的元素。 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt; &lt;context:component-scan base-package=&quot;com.spring.aop.helloworld&quot;&gt;&lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; &lt;/beans&gt; 3.6 环绕通知环绕通知包括了以上的四种通知。因此单独拿出来。其类似于动态代理，先看代码： @Around(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;) public Object aroundMethod(ProceedingJoinPoint pJoinPoint) { Object result = 0.0; String methodName = pJoinPoint.getSignature().getName(); // 执行目标方法 try { // 前置通知 System.out.println(&quot;The Method &quot; + methodName + &quot; Begin with &quot; + Arrays.asList(pJoinPoint.getArgs())); result = pJoinPoint.proceed(); // 返回通知 System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result); } catch (Throwable e) { System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e); } //后置通知 System.out.println(&quot;The Method &quot; + methodName + &quot; End&quot;); return result; } 注意一下几点： 环绕通知类似于动态代理的全过程：ProceedingJoinPoint 参数可以决定是否执行目标方法。 环绕通知必须有返回值，返回值即为目标方法的返回值。 环绕通知需要携带 ProceedingJoinPoint 类型的参数。通过此参数可以获取激活此通知的方法的相关信息。 4 简单实例（使用XML配置）4.1 编写测试用例：接口与类在此依旧使用上面的接口类。 需要改变的是切面类。去掉其中的所有注解，只是简单的JAVA类。我们将使用 XML 配置的方式一一配置。 public class LogginAspectj { public void beforeMethod(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;); } public void afterMethod(JoinPoint joinPoint) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;); } public void afterReturning(JoinPoint joinPoint, Object result) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result); } public void afterThrowing(JoinPoint joinPoint, Exception e) { String methodName = joinPoint.getSignature().getName(); System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e); } } 4.2 Spring 配置文件4.2.1 配置 bean&lt;!-- 配置 bean --&gt; &lt;bean id=&quot;simpleCalculator&quot; class=&quot;com.spring.aop.xml.SimpleCalculatorImpl&quot;&gt;&lt;/bean&gt; &lt;!-- 配置切面 bean --&gt; &lt;bean id=&quot;logginAspectj&quot; class=&quot;com.spring.aop.xml.LogginAspectj&quot;&gt;&lt;/bean&gt; 4.2.2 配置 AOP&lt;aop:config&gt; ......(4.2.3内容，4.2.4内容) &lt;/aop:config&gt; 4.2.3 配置切点表达式&lt;aop:pointcut expression=&quot;execution(* com.spring.aop.xml.SimpleCalculator.*(..))&quot; id=&quot;pointCut&quot; /&gt; 4.2.4 配置切面及通知&lt;!-- ref:指定哪个 bean 为切面 --&gt; &lt;aop:aspect ref=&quot;logginAspectj&quot;&gt; &lt;!-- 前置通知 --&gt; &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot; /&gt; &lt;!-- 后置通知 --&gt; &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot; /&gt; &lt;!-- 返回通知 --&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointCut&quot; returning=&quot;result&quot; /&gt; &lt;!-- 异常通知 --&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointCut&quot; throwing=&quot;e&quot; /&gt; &lt;/aop:aspect&gt; 属性介绍： method：指定此通知的方法。 pointcut-ref：引用切点。 returning：返回值。要与方法中的名称一致。 throwing：异常。要与方法中的名称一致。 5 小结面向切面编程（AOP）可以把分散在应用各处的相同的行为放入可重用的模块中，只需显式的声明此行为在何时何处使用。有效的减少了代码的冗余，使我们的类更多的关心自身的业务。 ————(以上为个人理解请多指教)2017/1/1 15:58:55]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[backbone-helloword 入门简单实例]]></title>
      <url>%2F2016%2F12%2F30%2Fbackbone-helloword%2F</url>
      <content type="text"><![CDATA[Backbone 简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js提供了一套web开发的框架，通过Models进行key-value绑定及custom事件处理,通过Collections提供一套丰富的API用于枚举功能,通过Views来进行事件处理及与现有的Application通过RESTful JSON接口进行交互.它是基于jquery和underscore的一个js框架。 主要组成 Model：创建数据模型，进行数据验证、销毁或者保存。 collection：model 的集合类。可以增加元素，删除元素，获取长度，排序，比较等一系列工具方法。 view：绑定 html 模板，绑定页面元素的时间，初始的渲染，模型值改变后的重新渲染和界面元素的销毁等。 Router：是对路由的处理，就像传统网站通过url现实不同的页面，在单页面应用（SPA）中通过Router来控制前面说的View的展示。 中文 API 网址：http://www.css88.com/doc/backbone/ Backbone 源码：https://github.com/jashkenas/backbone/ Backbone.js入门教程第二版：http://www.kancloud.cn/kancloud/backbonejs-learning-note underscore.js中文文档：http://www.css88.com/doc/underscore/ HelloWorld 简单 Demo 实例加入相关 JS&lt;script type=&quot;text/javascript&quot; src=&quot;../jquery-1.8.3.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../underscore.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../backbone.js&quot;&gt;&lt;/script&gt; JS 说明 jquery-1.8.3.js：jQuery 相关，非必须。 underscore.js：Backbone 的唯一重度依赖 js。提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。 backbone.js：这个自然为 backbone 的核心 js。 js 加入顺序就按我的来就行。 js 代码&lt;script type=&quot;text/javascript&quot;&gt; $(function(){ // 创建一个 World 模型 var Word = Backbone.Model.extend({ defaults:{ context:&quot;没什么想说的！&quot; } }); //创建一个 World 集合 var Words = Backbone.Collection.extend({ modle:Word //指定集合中的 model }); var words = new Words; //创建整个 body 视图 var AppView = Backbone.View.extend({ el:$(&quot;body&quot;), events:{ &quot;click #say&quot;:&quot;say&quot; //为 id=&quot;say&quot; 的按钮绑定单击事件 }, //初始化 initialize: function () { this.input = $(&quot;#context&quot;); //监听器 对 words 集合的 add 事件监听，回调函数 addWord this.listenTo(words,&quot;add&quot;,this.addWord); }, //对应上面 say say:function(){ var s = this.input.val(); var word; if (s == &quot;&quot;) { word = new Word; }else{ word = new Word({context:s}); } words.add(word); this.input.val(&quot;&quot;); }, //对应上面的 addWord addWord:function(model){ $(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot; + model.get(&quot;context&quot;) + &quot;&lt;/li&gt;&quot;); } }); //创建视图实例 var appView = new AppView; }) &lt;/script&gt; 这个简单的 helloworld 实例，涉及到 Model、Collection、View，每发送一句话代表就创建一个 model，并将这句话加入 collection 集合中，“add” 事件触发 addWord 方法，在 id 为 list 的ul 中加入一个 li 标签。 helloworld 结束语backbone 讲传统的 js mvc化，即模型、控制、视图分开开来，使前端与 server 的交互变得简单。有此优点：根据模型的变更自动更新应用程序的 HTML，有助于代码维护，同时促进客户端模块的使用，避免了在 JavaScript 中嵌套 Html 代码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“单例”]]></title>
      <url>%2F2016%2F12%2F25%2Fjava_singleton%2F</url>
      <content type="text"><![CDATA[Java 单例概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式应该算是 23 种设计模式中最简单的一种模式了。所谓“单例”：就是一个类只有一个实例。因此，单例模式有以下三个要素： 私有构造方法 指向自己实例的私有静态引用 一个返回自己实例的公有方法。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式根据对象实例化时机分为两种：饿汉式与懒汉式。饿汉式：类在加载时就实例化一个对象；懒汉式：使用时实例化。 单例的实现饿汉式单例package com.wenka.singleton; public class Person1 { private final static Person1 PERSON1 = new Person1(); private Person1() { } public static Person1 getInstance() { return PERSON1; } } 懒汉式单例（一）package com.wenka.singleton; public class Person2 { private static Person2 person2; private Person2() { } public synchronized static Person2 getInstance() { if (person2 == null) { person2 = new Person2(); } return person2; } } 简要说明synchronized：将获取单例类实例的方法原子性、不可分割，有效避免了在多线程情况下出现创建不同对象的情况。 懒汉式单例（二）package com.wenka.singleton; public class Person3 { private static Person3 person; private Person3() { } public static Person3 getInstance() { if (person == null) { synchronized (Person3.class) { if (person == null) { person = new Person3(); } } } return person; } } 简要说明相比第一种懒汉式单例的方法，此次将 synchronized 同步代码块放入方法内容，这样只有在第一次创建到单例对象的时候，才会获取对象锁。一旦单例对象存在，将不用再如（一）一般每次获取单例对象都要进行获取锁，释放锁，大大提高了运行效率。 单例的优点 在内存中只创建了一个对象，节省了内存空间。 避免了频繁的创建、销毁对象。 避免对共享资源的多重占用。 全局访问。 结尾单例模式使用的场景：频繁的创建销毁对象，有状态的工具类对象。但是需要注意的是：不能使用反射创建单例对象，将会得到不同的对象。 本文源码：https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“线程”]]></title>
      <url>%2F2016%2F12%2F24%2Fjava_thread%2F</url>
      <content type="text"><![CDATA[Java 线程线程概述&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。 创建新执行线程有两种方法： 一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。 创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。 线程的创建java.lang.Thread 类的构造方法Thread() //① 分配新的 Thread 对象 Thread(Runnable target) //② 参数为：实现 Runnable 接口的类 Thread(Runnable target, String name) //③ 如②，并为此线程命名。 Thread(String name) //如① ,并为线程命名。 方法一：继承 Thread 类。class Thread1 extends Thread{ @Override public void run() { for(int i = 0; i &lt; 10; i++){ System.out.println(i + &quot; ---&gt;Thread&quot;); } } } 线程启动：调用构造方法① Thread1 thread1 = new Thread1(); thread1.start(); 方法二：实现 Runnable 接口。class Target implements Runnable{ @Override public void run() { for(int i = 0; i &lt; 10; i++){ System.out.println(i + &quot; ---&gt;target&quot;); } } } 线程启动：调用构造方法② Target target = new Target(); new Thread(target).start(); 线程常用方法Thread.currentThread()：获取当前线程 start()：启动线程 getName()：获取当前线程的名字 setName()：设置当前线程的名字 sleep()：睡眠。定时。 join()： 等待该线程终止。 线程之间的通信（一）：生产者消费者问题问题表述仓库类 Products： 描述仓库库存大小，及储存商品。 线程 Producter 表示生产者：生产产品，并放入仓库中，每次生产一件商品。若商品数量达到仓库库存大小时，生产等待;若商品数量小于仓库库存时，则继续生产。 线程 Consumer 表示消费者： 购买商品。每次购买一件商品。若库存为 0 时，停止购买，消费等待;若仓库存在商品，则继续购买。 编码声明仓库类class Products{ static int maxSize = 10;//仓库大小 static Queue&lt;Integer&gt; products = new LinkedList&lt;Integer&gt;(); //产品队列 } 生产者线程//生产者 class Producter extends Thread{ @Override public void run() { int i = 0; while (true) { synchronized (Products.class) { while (Products.products.size() == Products.maxSize) { System.out.println(&quot;仓库已经满了&quot;); try { Products.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + &quot;生产出来的产品编号：&quot; + i); Products.products.add(i); i++; Products.class.notifyAll(); } } } } 消费者线程//消费者 class Consumer extends Thread{ @Override public void run() { while (true) { synchronized (Products.class) { while (Products.products.isEmpty()) { System.out.println(&quot;仓库为空&quot;); try { Products.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() +&quot;消费的产品编号 : &quot; + Products.products.remove()); Products.class.notifyAll(); //唤醒生产者线程生产产品 } } } } 测试 编写 Main 方法public class MainTest { public static void main(String[] args) { Producter producter = new Producter(); Consumer consumer = new Consumer(); producter.setName(&quot;Products-----&gt;&quot;); consumer.setName(&quot;Consumer-----&gt;&quot;); producter.start(); consumer.start(); } } 代码详解 synchronized 关键字：同步代码块，原子操作 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized 来给对象和方法或者代码块加锁，当它为一个方法或者一个代码块加锁的时候，只能有一个线程执行这段代码。当两个并发线程访问同一个对象的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后，释放锁，才能执行该代码块。 wait() 方法：线程等待 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前对象必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于某一个参数的版本，实现中断和虚假唤醒是可能的，而且此方法应始终在循环中使用 notifyAll() 方法：唤醒 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。 线程之间的通信（二）：多线程顺序打印“ABC”问题描述 线程A 负责打印“A”； 线程B 负责打印“B”； 线程C 负责打印“C”。 编码公用类class PrintABC { static Integer flag = 1; static void printA() { System.out.println(&quot;A&quot;); } static void printB() { System.out.println(&quot;B&quot;); } static void printC() { System.out.println(&quot;C&quot;); } } A线程// 打印 A class ThreadA extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 1) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printA(); PrintABC.flag = 2; PrintABC.class.notifyAll(); } } } } B线程// 打印 B class ThreadB extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 2) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printB(); PrintABC.flag = 3; PrintABC.class.notifyAll(); } } } } C线程//打印 C class ThreadC extends Thread { @Override public void run() { for (int i = 0; i &lt; 10; i++) { synchronized (PrintABC.class) { while (PrintABC.flag != 3) { try { PrintABC.class.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } PrintABC.printC(); PrintABC.flag = 1; PrintABC.class.notifyAll(); } } } } 测试 Main 方法public class MainClass { public static void main(String[] args) { new ThreadA().start(); new ThreadB().start(); new ThreadC().start(); } } 总结本文对 Java 多线程的通信进行了简单的描述，欢迎对此文的补充。代码：https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[苦行僧 Java 笔记之“反射”]]></title>
      <url>%2F2016%2F12%2F23%2Fjava_reflect%2F</url>
      <content type="text"><![CDATA[java反射1、什么是反射？JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。 2、反射用来干什么？判断任意一个对象所属的类；调用其构造方法构造类的实例；获取、操作任意一个类所具 有的成员变量和方法；在运行时调用任意一个对象的方法等。 3、怎么用呢？首先我们先创建一个普通的 Demo 类。 12345package com.wenka.reflect;public class Demo &#123; public Demo() &#123; &#125; &#125; ####3.1 获取 Class三种方式获取 Class 对象： 123Class&lt;?&gt; demo1 = null;Class&lt;?&gt; demo2 = null;Class&lt;?&gt; demo3 = null; ① 通过 Class 类的静态方法 forName(String className)，参数为需要获取 Class 的类的全类名。 1demo1 = Class.forName(&quot;com.wenka.reflect.Demo&quot;); 注意：这里 ClassNotFoundException 异常需要处理，由于我们只是测试用，所以在这里选择上抛。 -② 从此类的实例中获取 1demo2 = new Demo().getClass(); -② 从类名中获取 1demo3 = Demo.class; -输出结果： 123demo1：class com.wenka.reflect.Demodemo2：class com.wenka.reflect.Demodemo3：class com.wenka.reflect.Demo ####3.2 获取到 Class 有什么用呢？？相信对于初学者也如当初的我一样，不知道接下来能干什么？这时，我们看一下 JavaAPI：java.lang.Class&lt;T&gt; 这个类。没错，我们可以通过它获取各种方法、各种属性等。 ① 在此之前先创建一个 Person 类方便测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.wenka.reflect;public class Person &#123; //两个私有属性 private String name; private Integer age; //两个私有属性的 getter/setter 方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; //重写 toString() 方法输出测试。 @Override public String toString() &#123; return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;; &#125; //写了四个构造方法：一个两参的，一个public一参的，一个private一参的，一个无参的。 public Person(String name, Integer age) &#123; super(); this.name = name; this.age = age; &#125; public Person(String name) &#123; this(name, 20); &#125; @SuppressWarnings(&quot;unused&quot;) private Person(Integer age) &#123; this(&quot;zhangsan&quot;, age); &#125; public Person() &#123; &#125; //两个私有方法：有参 work(int hours)、 无参 salary() @SuppressWarnings(&quot;unused&quot;) private void work(int hours) &#123; System.out.println(name + &quot;工作了&quot; + hours + &quot;个小时&quot;); &#125; @SuppressWarnings(&quot;unused&quot;) private double salary() &#123; return 5000; &#125;&#125; ② 获取构造方法 获取 Class 1Class&lt;?&gt; demo = Class.forName(&quot;com.wenka.reflect.Person&quot;); - 通过 API 发现有两个获取所有构造参数的方法。 getConstructors() 和 getDeclaredConstructors()通过对比发现：getConstructors()：不能获取到类的私有构造方法，而 getDeclaredConstructors() 则可以获取到所有的构造方法。 - 获取到指定的构造方法： - getConstructor(Class&lt;*?*&gt;... parameterTypes) 和 getConstructor(Class&lt;*?*&gt;... parameterTypes) 参数列表为想要的获取的那个构造方法所对应的参数列表楼主在此获取得到 public 参数列表为 String 的构造方法。通过调用 Constructor&lt;T&gt; 中的 newInstance(Object… initargs) 方法创建实例。此方法的参数列表就是对应的构造方法的参数列表的实参。 `Person person = (Person) demo.getConstructor(String.class).newInstance(&quot;wangwu&quot;); ` - 在此就有了疑问，既然我们可以通过 getDeclaredConstructor(Class&lt;*?*&gt;... parameterTypes) 获取到 **私有**的方法，那我们是不是也能通过此种办法，使得我们可以利用私有**构造方法**来创建实例？ `Constructor&lt;?&gt; constructor = demo.getDeclaredConstructor(Integer.class);` 没错，我们通过此方法获取到了私有构造方法，但是我们直接通过此创建实例会有异常： 1java.lang.IllegalAccessException: Class com.wenka.reflect.MainClass can not access a member of class com.wenka.reflect.Person with modifiers &quot;private&quot; 意思是说：这个构造方法是 “private”的，我们不能访问。但是，不要灰心，自习看了一下 Constructor&lt;*T*&gt; 类，Field、Method 和 Constructor 对象的基类为 **AccessibleObject** 类，这个类是干什么呢？ **它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。**哦，原来这个类可以取消 Java 语言的访问控制检查的能力啊。这就好办了。我们讲刚得到的私有构造方法 调用 setAccessible(boolean flag) 方法。将此方法设置为 false，使其取消反射的对象实施 Java 语言访问检查。 1constructor.setAccessible(true); 到此： 12Object newInstance = constructor.newInstance(20);System.out.println(newInstance); 输出： 1Person [name=zhangsan, age=20] 如果只能通过无参的构造方法来创建实例就比较简单了：当然前提是一定要有无参构造。 1234Person person = (Person) Demo.newInstance(); person.setAge(20); person.setName(&quot;A&quot;); System.out.println(person); ③ 获取字段 获取所有字段，与获取构造方法类似。调用 getDeclaredFields() 或者 getFields() 获取指定字段并赋值。getDeclaredField(String name) 参数：字段名。 12Field field = demo.getDeclaredField(&quot;age&quot;);field.setAccessible(true); 为字段设置新值： 1234Person person = new Person(&quot;AAAAAA&quot;);//field.set(obj, value);给 obj 对象的此属性设置 value 新值field.set(person, 100);System.out.println(person) ④ 获取方法 获取所有方法：getMethods()和 getDeclaredMethods(); 获取指定的方法：（在此依旧是获取 private 的方法，其它方法类似。） 当初我们创建的实体类中有 两个私有方法：有参 work(int hours)、 无参 salary() getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：参数列表为：1.方法名，2. 对应方法的参数列表的类型，0个 或者 多个。 123456Method work = demo.getDeclaredMethod(&quot;work&quot;, int.class); System.out.println(work);work.setAccessible(true);Person person = new Person(&quot;AAAA&quot;);// invoke(Object obj, Object... args) work.invoke(person, 10); 输出结果： 12private void com.wenka.reflect.Person.work(int)AAAA工作了10个小时 Method 类中的 invoke(Object obj, Object… args) 方法，对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。 参数：1.指定对象 2.对应参数列表的实参。 倘若方法有返回值，则直接返回： Method salary = demo.getDeclaredMethod(&quot;salary&quot;); salary.setAccessible(true); Object invoke = salary.invoke(person); System.out.println(&quot;得到了工资：&quot; + invoke); 结果为： 1得到了工资：5000.0 致此：反射的简单用法都已经写完了，可以发现，反射很强大的，我们甚至可以通过反射使 单例 不再单例，通过反射获取注释，接口等关于此类的所有信息，并从底层操作。未来学习的框架都运用了反射的原理来实现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F12%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
