<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenKa Blog</title>
  <subtitle>文卡 博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenka.github.io/"/>
  <updated>2016-12-25T08:53:56.971Z</updated>
  <id>https://wenka.github.io/</id>
  
  <author>
    <name>文卡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>苦行僧 Java 笔记之“单例”</title>
    <link href="https://wenka.github.io/2016/12/25/java_singleton/"/>
    <id>https://wenka.github.io/2016/12/25/java_singleton/</id>
    <published>2016-12-25T08:13:27.000Z</published>
    <updated>2016-12-25T08:53:56.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-单例"><a href="#Java-单例" class="headerlink" title="Java 单例"></a>Java 单例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式应该算是 23 种设计模式中最简单的一种模式了。所谓“单例”：就是一个类只有一个实例。因此，单例模式有以下三个要素：</p>
<ol>
<li>私有构造方法</li>
<li>指向自己实例的私有静态引用</li>
<li>一个返回自己实例的公有方法。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式根据对象实例化时机分为两种：<strong>饿汉式</strong>与<strong>懒汉式</strong>。饿汉式：类在加载时就实例化一个对象；懒汉式：使用时实例化。</p>
<h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><pre><code>package com.wenka.singleton;

public class Person1 {

    private final static Person1 PERSON1 = new Person1();

    private Person1() {

    }

    public static Person1 getInstance() {
        return PERSON1;
    }
}
</code></pre><h3 id="懒汉式单例（一）"><a href="#懒汉式单例（一）" class="headerlink" title="懒汉式单例（一）"></a>懒汉式单例（一）</h3><pre><code>package com.wenka.singleton;

public class Person2 {

    private static Person2 person2;

    private Person2() {

    }

    public synchronized static Person2 getInstance() {
        if (person2 == null) {
            person2 = new Person2();
        }
        return person2;
    }
}
</code></pre><h4 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h4><p><strong>synchronized：</strong>将获取单例类实例的方法原子性、不可分割，有效避免了在多线程情况下出现创建不同对象的情况。</p>
<h3 id="懒汉式单例（二）"><a href="#懒汉式单例（二）" class="headerlink" title="懒汉式单例（二）"></a>懒汉式单例（二）</h3><pre><code>package com.wenka.singleton;

public class Person3 {

    private static Person3 person;

    private Person3() {

    }

    public static Person3 getInstance() {

        if (person == null) {
            synchronized (Person3.class) {
                if (person == null) {
                    person = new Person3();
                }
            }
        }

        return person;
    }
}
</code></pre><h4 id="简要说明-1"><a href="#简要说明-1" class="headerlink" title="简要说明"></a>简要说明</h4><p>相比第一种懒汉式单例的方法，此次将 synchronized 同步代码块放入方法内容，这样只有在第一次创建到单例对象的时候，才会获取对象锁。一旦单例对象存在，将不用再如（一）一般每次获取单例对象都要进行获取锁，释放锁，大大提高了运行效率。</p>
<h2 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h2><ul>
<li>在内存中只创建了一个对象，节省了内存空间。</li>
<li>避免了频繁的创建、销毁对象。</li>
<li>避免对共享资源的多重占用。</li>
<li>全局访问。</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>单例模式使用的场景：频繁的创建销毁对象，有状态的工具类对象。但是需要注意的是：不能使用反射创建单例对象，将会得到不同的对象。</p>
<p>本文源码：<a href="https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton" title="Java单例模式" target="_blank" rel="external">https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton</a></p>
]]></content>
    
    <summary type="html">
    
      创建单例的三种方法。
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="java" scheme="https://wenka.github.io/tags/java/"/>
    
      <category term="单例" scheme="https://wenka.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>苦行僧 Java 笔记之“线程”</title>
    <link href="https://wenka.github.io/2016/12/24/java_thread/"/>
    <id>https://wenka.github.io/2016/12/24/java_thread/</id>
    <published>2016-12-24T09:26:41.000Z</published>
    <updated>2016-12-25T08:18:08.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。</p>
<p>创建新执行线程有两种方法：</p>
<ol>
<li><p>一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。</p>
</li>
<li><p>创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。</p>
</li>
</ol>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="java-lang-Thread-类的构造方法"><a href="#java-lang-Thread-类的构造方法" class="headerlink" title="java.lang.Thread 类的构造方法"></a>java.lang.Thread 类的构造方法</h3><pre><code>Thread() //① 分配新的 Thread 对象
Thread(Runnable target)  //② 参数为：实现 Runnable 接口的类
Thread(Runnable target, String name)  //③ 如②，并为此线程命名。
Thread(String name) //如① ,并为线程命名。
</code></pre><h3 id="方法一：继承-Thread-类。"><a href="#方法一：继承-Thread-类。" class="headerlink" title="方法一：继承 Thread 类。"></a>方法一：继承 Thread 类。</h3><pre><code>class Thread1 extends Thread{
    @Override
    public void run() {
        for(int i = 0; i &lt; 10; i++){
            System.out.println(i + &quot; ---&gt;Thread&quot;);
        }
    }
}
</code></pre><p>线程启动：调用构造方法①</p>
<pre><code>Thread1 thread1 = new Thread1();
thread1.start();
</code></pre><h3 id="方法二：实现-Runnable-接口。"><a href="#方法二：实现-Runnable-接口。" class="headerlink" title="方法二：实现 Runnable 接口。"></a>方法二：实现 Runnable 接口。</h3><pre><code>class Target implements Runnable{

    @Override
    public void run() {
        for(int i = 0; i &lt; 10; i++){
            System.out.println(i + &quot; ---&gt;target&quot;);
        }
    }

}
</code></pre><p>线程启动：调用构造方法②</p>
<pre><code>Target target = new Target();
new Thread(target).start();
</code></pre><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><pre><code>Thread.currentThread()：获取当前线程
start()：启动线程
getName()：获取当前线程的名字
setName()：设置当前线程的名字
sleep()：睡眠。定时。
join()： 等待该线程终止。
</code></pre><h2 id="线程之间的通信（一）：生产者消费者问题"><a href="#线程之间的通信（一）：生产者消费者问题" class="headerlink" title="线程之间的通信（一）：生产者消费者问题"></a>线程之间的通信（一）：生产者消费者问题</h2><h3 id="问题表述"><a href="#问题表述" class="headerlink" title="问题表述"></a>问题表述</h3><p><strong>仓库类 Products</strong>： 描述仓库库存大小，及储存商品。</p>
<p><strong>线程 Producter</strong> 表示生产者：生产产品，并放入仓库中，每次生产一件商品。若商品数量达到仓库库存大小时，生产等待;若商品数量小于仓库库存时，则继续生产。</p>
<p><strong>线程 Consumer</strong> 表示消费者： 购买商品。每次购买一件商品。若库存为 0 时，停止购买，消费等待;若仓库存在商品，则继续购买。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="声明仓库类"><a href="#声明仓库类" class="headerlink" title="声明仓库类"></a>声明仓库类</h4><pre><code>class Products{
    static int maxSize = 10;//仓库大小
    static Queue&lt;Integer&gt; products = new LinkedList&lt;Integer&gt;(); //产品队列
}
</code></pre><h4 id="生产者线程"><a href="#生产者线程" class="headerlink" title="生产者线程"></a>生产者线程</h4><pre><code>//生产者
class Producter extends Thread{

    @Override
    public void run() {
        int i = 0;
        while (true) {
            synchronized (Products.class) {

                while (Products.products.size() == Products.maxSize) {
                    System.out.println(&quot;仓库已经满了&quot;);
                    try {
                        Products.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;生产出来的产品编号：&quot; + i);
                Products.products.add(i);
                i++;
                Products.class.notifyAll();
            }
        }

    }
}
</code></pre><h4 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h4><pre><code>//消费者
class Consumer extends Thread{
    @Override
    public void run() {
        while (true) {
            synchronized (Products.class) {
                while (Products.products.isEmpty()) {
                    System.out.println(&quot;仓库为空&quot;);
                    try {
                        Products.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() +&quot;消费的产品编号 : &quot; + Products.products.remove()); 
                Products.class.notifyAll(); //唤醒生产者线程生产产品
            }
        }
    }
}
</code></pre><h4 id="测试-编写-Main-方法"><a href="#测试-编写-Main-方法" class="headerlink" title="测试 编写 Main 方法"></a>测试 编写 Main 方法</h4><pre><code>public class MainTest {
    public static void main(String[] args) {
        Producter producter = new Producter();
        Consumer consumer = new Consumer();

        producter.setName(&quot;Products-----&gt;&quot;);
        consumer.setName(&quot;Consumer-----&gt;&quot;);

        producter.start();
        consumer.start();
    }
}
</code></pre><h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><ul>
<li><p><strong>synchronized</strong> 关键字：<strong>同步代码块，原子操作</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized 来给对象和方法或者代码块加锁，当它为一个方法或者一个代码块加锁的时候，只能有一个线程执行这段代码。当两个并发线程访问同一个对象的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后，释放锁，才能执行该代码块。</p>
</li>
<li><p><strong>wait()</strong> 方法：<strong>线程等待</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前对象必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行。 </p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于某一个参数的版本，实现中断和虚假唤醒是可能的，而且此方法应始终在<strong>循环</strong>中使用</p>
</li>
<li><p><strong>notifyAll()</strong> 方法：<strong>唤醒</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。</p>
</li>
</ul>
<h2 id="线程之间的通信（二）：多线程顺序打印“ABC”"><a href="#线程之间的通信（二）：多线程顺序打印“ABC”" class="headerlink" title="线程之间的通信（二）：多线程顺序打印“ABC”"></a>线程之间的通信（二）：多线程顺序打印“ABC”</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li><p>线程A 负责打印“A”；</p>
</li>
<li><p>线程B 负责打印“B”；</p>
</li>
<li><p>线程C 负责打印“C”。</p>
</li>
</ol>
<h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><h4 id="公用类"><a href="#公用类" class="headerlink" title="公用类"></a>公用类</h4><pre><code>class PrintABC {

    static Integer flag = 1;

    static void printA() {
        System.out.println(&quot;A&quot;);
    }

    static void printB() {
        System.out.println(&quot;B&quot;);
    }

    static void printC() {
        System.out.println(&quot;C&quot;);
    }
}
</code></pre><h4 id="A线程"><a href="#A线程" class="headerlink" title="A线程"></a>A线程</h4><pre><code>// 打印 A
class ThreadA extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 1) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printA();
                PrintABC.flag = 2;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="B线程"><a href="#B线程" class="headerlink" title="B线程"></a>B线程</h4><pre><code>// 打印 B
class ThreadB extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 2) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printB();
                PrintABC.flag = 3;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="C线程"><a href="#C线程" class="headerlink" title="C线程"></a>C线程</h4><pre><code>//打印 C
class ThreadC extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 3) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printC();
                PrintABC.flag = 1;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="测试-Main-方法"><a href="#测试-Main-方法" class="headerlink" title="测试 Main 方法"></a>测试 Main 方法</h4><pre><code>public class MainClass {
    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Java 多线程的通信进行了简单的描述，欢迎对此文的补充。<br>代码：<a href="https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread" title="Java线程" target="_blank" rel="external">https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread</a></p>
]]></content>
    
    <summary type="html">
    
      Java 线程的两个特殊例子：生产者消费者问题，线程通信顺序打印“ABC”
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wenka.github.io/tags/Java/"/>
    
      <category term="线程" scheme="https://wenka.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://wenka.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>苦行僧 Java 笔记之“反射”</title>
    <link href="https://wenka.github.io/2016/12/23/java_reflect/"/>
    <id>https://wenka.github.io/2016/12/23/java_reflect/</id>
    <published>2016-12-23T11:28:41.000Z</published>
    <updated>2016-12-25T08:17:49.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><h3 id="1、什么是反射？"><a href="#1、什么是反射？" class="headerlink" title="1、什么是反射？"></a>1、什么是反射？</h3><pre><code>JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。
</code></pre><h3 id="2、反射用来干什么？"><a href="#2、反射用来干什么？" class="headerlink" title="2、反射用来干什么？"></a>2、反射用来干什么？</h3><pre><code>判断任意一个对象所属的类；调用其构造方法构造类的实例；获取、操作任意一个类所具
有的成员变量和方法；在运行时调用任意一个对象的方法等。
</code></pre><a id="more"></a>
<h3 id="3、怎么用呢？"><a href="#3、怎么用呢？" class="headerlink" title="3、怎么用呢？"></a>3、怎么用呢？</h3><p>首先我们先创建一个普通的 Demo 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package com.wenka.reflect;</div><div class="line">public class Demo &#123;</div><div class="line">	public Demo() &#123;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####3.1 获取 Class<br><strong>三种方式获取 Class 对象：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; demo1 = null;</div><div class="line">Class&lt;?&gt; demo2 = null;</div><div class="line">Class&lt;?&gt; demo3 = null;</div></pre></td></tr></table></figure>
<ul>
<li><strong>① 通过 Class 类的静态方法 forName(String className)，参数为需要获取 Class 的类的</strong>全类名<strong>。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo1 = Class.forName(&quot;com.wenka.reflect.Demo&quot;);</div></pre></td></tr></table></figure>
<p>注意：这里 ClassNotFoundException  异常需要处理，由于我们只是测试用，所以在这里选择上抛。</p>
<p>-<strong>② 从此类的实例中获取</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo2 = new Demo().getClass();</div></pre></td></tr></table></figure>
<p>-<strong>② 从类名中获取</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo3 = Demo.class;</div></pre></td></tr></table></figure>
<p>-<strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">demo1：class com.wenka.reflect.Demo</div><div class="line">demo2：class com.wenka.reflect.Demo</div><div class="line">demo3：class com.wenka.reflect.Demo</div></pre></td></tr></table></figure>
<p>####3.2 获取到 Class 有什么用呢？？<br>相信对于初学者也如当初的我一样，不知道接下来能干什么？这时，我们看一下 JavaAPI：java.lang.Class&lt;<em>T</em>&gt; 这个类。没错，我们可以通过它获取各种方法、各种属性等。</p>
<ul>
<li><strong>① 在此之前先创建一个 Person 类方便测试</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package com.wenka.reflect;</div><div class="line"></div><div class="line">public class Person &#123;</div><div class="line"></div><div class="line">	//两个私有属性</div><div class="line">	private String name;</div><div class="line">	private Integer age;</div><div class="line"></div><div class="line">	//两个私有属性的 getter/setter 方法</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Integer getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setAge(Integer age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//重写 toString() 方法输出测试。</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//写了四个构造方法：一个两参的，一个public一参的，一个private一参的，一个无参的。</div><div class="line">	public Person(String name, Integer age) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Person(String name) &#123;</div><div class="line">		this(name, 20);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private Person(Integer age) &#123;</div><div class="line">		this(&quot;zhangsan&quot;, age);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Person() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//两个私有方法：有参 work(int hours)、 无参 salary()</div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private void work(int hours) &#123;</div><div class="line">		System.out.println(name + &quot;工作了&quot; + hours + &quot;个小时&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private double salary() &#123;</div><div class="line">		return 5000;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>② 获取构造方法</strong></p>
<ul>
<li><p>获取 Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; demo = Class.forName(&quot;com.wenka.reflect.Person&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- 通过 API 发现有两个获取所有构造参数的方法。
</code></pre><p><strong>getConstructors()</strong> 和 <strong>getDeclaredConstructors()</strong><br>通过对比发现：getConstructors()：不能获取到类的私有构造方法，而 getDeclaredConstructors() 则可以获取到所有的构造方法。</p>
<pre><code>- 获取到指定的构造方法：
- getConstructor(Class&lt;*?*&gt;... parameterTypes) 和 getConstructor(Class&lt;*?*&gt;... parameterTypes) 
</code></pre><p>参数列表为想要的获取的那个构造方法所对应的参数列表<br>楼主在此获取得到 public 参数列表为 String 的构造方法。通过调用 Constructor&lt;<em>T</em>&gt; 中的 newInstance(Object… initargs)  方法创建实例。此方法的参数列表就是对应的构造方法的参数列表的实参。</p>
<pre><code>    `Person person = 
    (Person) demo.getConstructor(String.class).newInstance(&quot;wangwu&quot;);
    `
- 在此就有了疑问，既然我们可以通过 getDeclaredConstructor(Class&lt;*?*&gt;... parameterTypes) 获取到 **私有**的方法，那我们是不是也能通过此种办法，使得我们可以利用私有**构造方法**来创建实例？

 `Constructor&lt;?&gt; constructor = demo.getDeclaredConstructor(Integer.class);`

 没错，我们通过此方法获取到了私有构造方法，但是我们直接通过此创建实例会有异常：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessException: Class com.wenka.reflect.MainClass can not access a member of class com.wenka.reflect.Person with modifiers &quot;private&quot;</div></pre></td></tr></table></figure>

意思是说：这个构造方法是 “private”的，我们不能访问。但是，不要灰心，自习看了一下 Constructor&lt;*T*&gt; 类，Field、Method 和 Constructor 对象的基类为 **AccessibleObject** 类，这个类是干什么呢？
**它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。**哦，原来这个类可以取消 Java 语言的访问控制检查的能力啊。这就好办了。我们讲刚得到的私有构造方法
</code></pre><p>调用 setAccessible(boolean flag) 方法。将此方法设置为 false，使其取消反射的对象实施 Java 语言访问检查。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor.setAccessible(true);</div></pre></td></tr></table></figure>



到此：


    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object newInstance = constructor.newInstance(20);</div><div class="line">System.out.println(newInstance);</div></pre></td></tr></table></figure>


输出：

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person [name=zhangsan, age=20]</div></pre></td></tr></table></figure>


如果只能通过无参的构造方法来创建实例就比较简单了：当然前提是一定要有无参构造。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = (Person) Demo.newInstance();</div><div class="line">			person.setAge(20);</div><div class="line">			person.setName(&quot;A&quot;);</div><div class="line">			System.out.println(person);</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p><strong>③ 获取字段</strong></p>
<ul>
<li>获取所有字段，与获取构造方法类似。调用 <strong>getDeclaredFields()</strong> 或者 <strong>getFields() </strong></li>
<li><p>获取指定字段并赋值。<strong>getDeclaredField(String name) </strong>参数：字段名。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Field field = demo.getDeclaredField(&quot;age&quot;);</div><div class="line">field.setAccessible(true);</div></pre></td></tr></table></figure>
<p>  为字段设置新值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = new Person(&quot;AAAAAA&quot;);</div><div class="line">//field.set(obj, value);给 obj 对象的此属性设置 value 新值</div><div class="line">field.set(person, 100);</div><div class="line">System.out.println(person)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>④ 获取方法</strong></p>
<ul>
<li>获取所有方法：<strong>getMethods()</strong>和 <strong>getDeclaredMethods();</strong></li>
<li><p>获取指定的方法：（在此依旧是获取 private 的方法，其它方法类似。）</p>
<ul>
<li>当初我们创建的实体类中有 两个私有方法：有参 work(int hours)、 无参 salary()</li>
</ul>
<p><strong>getDeclaredMethod(String name, Class&lt;<em>?</em>&gt;… parameterTypes)</strong>：参数列表为：1.方法名，2. 对应方法的参数列表的类型，0个 或者 多个。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Method work = demo.getDeclaredMethod(&quot;work&quot;, int.class);</div><div class="line">			System.out.println(work);</div><div class="line">work.setAccessible(true);</div><div class="line">Person person = new Person(&quot;AAAA&quot;);</div><div class="line">// invoke(Object obj, Object... args) </div><div class="line">work.invoke(person, 10);</div></pre></td></tr></table></figure>
<p> 输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private void com.wenka.reflect.Person.work(int)</div><div class="line">AAAA工作了10个小时</div></pre></td></tr></table></figure>
<p>Method 类中的 <strong>invoke(Object obj, Object… args)</strong> 方法，<strong>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</strong> 参数：1.指定对象 2.对应参数列表的实参。</p>
<ul>
<li><p>倘若方法有返回值，则直接返回：</p>
<p><code>Method salary = demo.getDeclaredMethod(&quot;salary&quot;);
   salary.setAccessible(true);
   Object invoke = salary.invoke(person);
   System.out.println(&quot;得到了工资：&quot; + invoke);</code></p>
</li>
</ul>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">得到了工资：5000.0</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>致此：反射的简单用法都已经写完了，可以发现，反射很强大的，我们甚至可以通过反射使 单例 不再单例，通过反射获取注释，接口等关于此类的所有信息，并从底层操作。未来学习的框架都运用了反射的原理来实现。</p>
]]></content>
    
    <summary type="html">
    
      JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://wenka.github.io/tags/Java/"/>
    
      <category term="反射" scheme="https://wenka.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wenka.github.io/2016/12/21/hello-world/"/>
    <id>https://wenka.github.io/2016/12/21/hello-world/</id>
    <published>2016-12-21T14:41:19.830Z</published>
    <updated>2016-12-24T01:47:02.815Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
