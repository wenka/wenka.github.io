<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenKa Blog</title>
  <subtitle>文卡 博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenka.github.io/"/>
  <updated>2017-01-01T12:55:13.129Z</updated>
  <id>https://wenka.github.io/</id>
  
  <author>
    <name>文卡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring4笔记之IOC（一）</title>
    <link href="https://wenka.github.io/2017/01/01/Spring4-IOC/"/>
    <id>https://wenka.github.io/2017/01/01/Spring4-IOC/</id>
    <published>2017-01-01T10:41:51.000Z</published>
    <updated>2017-01-01T12:55:13.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-IOC-DI"><a href="#1-IOC-DI" class="headerlink" title="1 IOC(DI)"></a>1 IOC(DI)</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>IOC</strong>：控制反转，亦成为<strong>DI（依赖注入）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Spring应用中，应用对象生存与 <strong>Spring容器</strong> 中，Spring容器 负责创建对象，装配它们，配置它们并管理它们的生命周期。容器时 Spring 的核心，Spring 容器使用<strong>依赖注入</strong>管理构成应用的组件，创建相互协作的组件之间的关联。更多的我们通过<strong>应用上下文</strong>创建容器。</p>
<ul>
<li><strong>AnnotationConfigApplicationContext</strong>：从一个或者多个基于 Java 的配置类中加载 Spring 应用上下文。</li>
<li><strong>AnnotationConfigWebApplicationContext</strong>：从一个或者多个基于 Java 的配置类中记载 Spring Web 应用上下文。</li>
<li><strong>ClassPathXmlApplicationContext</strong>：从类路径下的一个或者多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li>
<li><strong>FileSystemXmlApplicationContext</strong>：从文件系统下的一个或者多个 XML 配置文件中加载上下文定义。</li>
<li><strong>XmlWebApplicationContext</strong>：从 Web 应用下的一个或者多个 XML 配置文件中记载上下文定义。</li>
</ul>
<p>如下：</p>
<pre><code>// 创建 spring 的 IOC 容器
ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
</code></pre><p>注意：创建 IOC 容器时，调用了对应 实体类的构造方法，和对应 属性 的 setter 方法。</p>
<h1 id="2-Spring-装配-Bean"><a href="#2-Spring-装配-Bean" class="headerlink" title="2 Spring 装配 Bean"></a>2 Spring 装配 Bean</h1><h2 id="2-1-在-XML-中显式配置"><a href="#2-1-在-XML-中显式配置" class="headerlink" title="2.1 在 XML 中显式配置"></a>2.1 在 XML 中显式配置</h2><p>applicationContext.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

......

&lt;/beans&gt;
</code></pre><p>要基于 XML 的 Spring 配置中声明一个 Bean，需要使用 spring-beans 模式的 &lt;<em>bean</em>&gt; 标签。</p>
<h3 id="2-1-1-属性注入"><a href="#2-1-1-属性注入" class="headerlink" title="2.1.1 属性注入"></a>2.1.1 属性注入</h3><ol>
<li><p>创建一个实体类 User</p>
<pre><code>public class User {
    private String name;

    public User() {
        super();
        System.out.println(&quot;构造方法......&quot;);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        System.out.println(&quot;setter......&quot;);
        this.name = name;
    }

    public void show(){
        System.out.println(&quot;Name：&quot; + name);
    }
}
</code></pre></li>
<li><p>在Spring配置文件装配 bean：</p>
 <bean id="user" class="com.spring.beans.User"><br>     <property name="name" value="spring"></property><br> </bean>

<ul>
<li>id：bean的标识。</li>
<li>class：指向创建这个 bean 的类，使用全限定的类名。</li>
<li>&lt;<em>property</em>&gt;标签：将字面量注入到属性中。<ul>
<li>name：指定哪个属性</li>
<li>value：值</li>
</ul>
</li>
</ul>
</li>
<li><p>从 IOC 容器中获取 bean</p>
<pre><code>User user = (User) context.getBean(&quot;user&quot;);
user.show();
</code></pre></li>
</ol>
<h3 id="2-1-2-构造器注入"><a href="#2-1-2-构造器注入" class="headerlink" title="2.1.2 构造器注入"></a>2.1.2 构造器注入</h3><ol>
<li><p>创建实体类</p>
<pre><code>public class Car {
    private String type;
    private String productPlace;
    private double price;
    private int speed;

    public Car() {
        super();
    }

    public Car(String type, String productPlace, double price) {
        super();
        this.type = type;
        this.productPlace = productPlace;
        this.price = price;
    }

    public Car(String type, String productPlace, int speed) {
        super();
        this.type = type;
        this.productPlace = productPlace;
        this.speed = speed;
    }

    ......(省略对应的 getter/setter 方法)

}
</code></pre></li>
</ol>
<ol>
<li><p>Spring配置文件：使用 &lt;<em>constructor-arg</em>&gt;标签</p>
<pre><code>&lt;bean id=&quot;car1&quot; class=&quot;com.spring.beans.Car&quot;&gt;
    &lt;constructor-arg value=&quot;Audi&quot; index=&quot;0&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;ShangHai&quot; index=&quot;1&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;300000&quot; index=&quot;2&quot; type=&quot;double&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><p> index、value：指定在构造方法中的第几个参数的value值。</p>
<p> 或者使用：</p>
<pre><code>&lt;bean id=&quot;car2&quot; class=&quot;com.spring.beans.Car&quot;&gt;
    &lt;constructor-arg value=&quot;Audi&quot;&gt;&lt;/constructor-arg&gt;
    &lt;constructor-arg&gt;
        &lt;value&gt;&lt;![CDATA[&lt;shanghai&gt;]]&gt;&lt;/value&gt;
    &lt;/constructor-arg&gt;
    &lt;constructor-arg value=&quot;200&quot; type=&quot;int&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre></li>
</ol>
<h3 id="2-1-3-bean-之间的引用"><a href="#2-1-3-bean-之间的引用" class="headerlink" title="2.1.3 bean 之间的引用"></a>2.1.3 bean 之间的引用</h3><p>创建 People 类：</p>
<pre><code>public class Person {
    private String name;
    private int age;
    private Car car;

    ......（省略对应的 getter/setter 方法）
}
</code></pre><p>People 中有 Car 类型的属性：</p>
<pre><code>&lt;bean id=&quot;person1&quot; class=&quot;com.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p><code>&lt;property name=&quot;car&quot; ref=&quot;car1&quot;&gt;&lt;/property&gt;</code> 中<strong>ref</strong>引用 id 为 car1 的bean。</p>
<p>还有一种方法，使用内部 bean ：</p>
<pre><code>&lt;bean id=&quot;person2&quot; class=&quot;com.spring.beans.Person&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;car&quot;&gt;
        &lt;bean class=&quot;com.spring.beans.Car&quot;&gt;
            &lt;property name=&quot;type&quot; value=&quot;BaoMa&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;productPlace&quot; value=&quot;BeiJing&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;speed&quot; value=&quot;200&quot;&gt;&lt;/property&gt;
            &lt;property name=&quot;price&quot; value=&quot;400000&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>但是需要注意：内部 bean 的引用 不能被其他 bean 引用。</p>
<h3 id="2-1-4-注入List-Set-集合"><a href="#2-1-4-注入List-Set-集合" class="headerlink" title="2.1.4 注入List(Set)集合"></a>2.1.4 注入List(Set)集合</h3><p>将 People 中的 car 改为集合类型 cars：</p>
<pre><code>public class People {
    private String name;
    private int age;
    private List&lt;Car&gt; cars;

    ......（省略构造方法及对应的 getter/setter 方法）
}
</code></pre><ol>
<li><p>内部装配<br>直接在&lt;<em>property</em>&gt;中使用 &lt;<em>list</em>&gt; 标签：</p>
<pre><code>&lt;bean id=&quot;people3&quot; class=&quot;com.spring.beans.collection.People&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cars&quot;&gt;
        &lt;list&gt;
            &lt;ref bean=&quot;car1&quot; /&gt;
            &lt;ref bean=&quot;car2&quot; /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ol>
<ol>
<li><p>使用外部装配</p>
<ul>
<li><p>先定义外部 list （在这里需要加入spring-util 的 schemaL，使用&lt;<em>util:list</em>&gt;标签）</p>
<pre><code>&lt;util:list id=&quot;cars&quot;&gt;
    &lt;bean class=&quot;com.spring.beans.Car&quot;&gt;
        &lt;property name=&quot;type&quot; value=&quot;BaoMa&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;productPlace&quot; value=&quot;BeiJing&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;speed&quot; value=&quot;200&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;price&quot; value=&quot;400000&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;ref bean=&quot;car2&quot; /&gt;
&lt;/util:list&gt;
</code></pre></li>
<li><p>引用外部 list </p>
<pre><code>&lt;bean id=&quot;people4&quot; class=&quot;com.spring.beans.collection.People&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cars&quot; ref=&quot;cars&quot;&gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre></li>
</ul>
</li>
</ol>
<h3 id="2-1-5-注入Map集合"><a href="#2-1-5-注入Map集合" class="headerlink" title="2.1.5 注入Map集合"></a>2.1.5 注入Map集合</h3><p>将 People 类中的 List&lt;<em>Car</em>&gt; cars 改为 Map&lt;<em>String, Car</em>&gt; cars：</p>
<pre><code>public class NewPeople {
    private String name;
    private int age;

    private Map&lt;String, Car&gt; cars;

    ......（省略构造方法及对应的 getter/setter 方法）
}
</code></pre><p>注入：</p>
<pre><code>&lt;bean id=&quot;people5&quot; class=&quot;com.spring.beans.collection.NewPeople&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;Tom&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;age&quot; value=&quot;23&quot;&gt;&lt;/property&gt;
    &lt;property name=&quot;cars&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;Car___1&quot;  value-ref=&quot;car1&quot; &gt;&lt;/entry&gt;
            &lt;entry key=&quot;Car___2&quot;  value-ref=&quot;car2&quot; &gt;&lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h2 id="2-2-基于注解方式"><a href="#2-2-基于注解方式" class="headerlink" title="2.2 基于注解方式"></a>2.2 基于注解方式</h2><p>Spring 从两个角度来实现自动化装配：</p>
<ol>
<li><strong>组件扫描</strong>：Spring 会自动发现应用上下文中所创建的 bean。</li>
<li><strong>自动装配</strong>：Spring 自动满足 bean 之间的依赖。</li>
</ol>
<h3 id="2-2-1-自动装配（为什么先说自动装配呢？因为要是没装配，扫描谁啊！）"><a href="#2-2-1-自动装配（为什么先说自动装配呢？因为要是没装配，扫描谁啊！）" class="headerlink" title="2.2.1 自动装配（为什么先说自动装配呢？因为要是没装配，扫描谁啊！）"></a>2.2.1 自动装配（为什么先说自动装配呢？因为要是没装配，扫描谁啊！）</h3><p>首先认识类上的四个注解：</p>
<ol>
<li>@Component：表名该类会作为组件类，并告知 Spring 要为这个类创建 bean。当组件不好归类时，使用这个。</li>
<li>@Repository：用于标注数据访问组件，即DAO组件。</li>
<li>@Service：用于标注业务层组件。</li>
<li>@Controller：用于标注控制层组件。</li>
<li>@Autowired：默认按类型自动装配。</li>
</ol>
<h3 id="2-2-2-设置组自动扫描"><a href="#2-2-2-设置组自动扫描" class="headerlink" title="2.2.2 设置组自动扫描"></a>2.2.2 设置组自动扫描</h3><p>需要加入 context 命名空间。</p>
<pre><code>&lt;context:component-scan base-package=&quot;com.spring&quot;&gt;&lt;/context:component-scan&gt;
</code></pre><p>base-package：表名需要扫描的包。</p>
<h1 id="3-结束语"><a href="#3-结束语" class="headerlink" title="3 结束语"></a>3 结束语</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring的核心就是 Spring 容器。容器负责管理应用中组件的生命周期，它会创建这些组件并保证它们的依赖能够得到满足，这样才能完成业务功能。本人还是感觉基于注解方式配置bean比较方便些。</p>
<p><em>（——继续努力，请多多指教！2017/1/1 20:49:17 ）</em></p>
]]></content>
    
    <summary type="html">
    
      讲述分别基于注解和XML配置文件方式配置 Bean，以及相关类型属性的注入方式。
    
    </summary>
    
      <category term="Spring4" scheme="https://wenka.github.io/categories/Spring4/"/>
    
    
      <category term="MVC" scheme="https://wenka.github.io/tags/MVC/"/>
    
      <category term="IOC" scheme="https://wenka.github.io/tags/IOC/"/>
    
      <category term="DI" scheme="https://wenka.github.io/tags/DI/"/>
    
  </entry>
  
  <entry>
    <title>Spring4笔记之 AOP</title>
    <link href="https://wenka.github.io/2017/01/01/Spring4-Aop/"/>
    <id>https://wenka.github.io/2017/01/01/Spring4-Aop/</id>
    <published>2017-01-01T05:57:29.000Z</published>
    <updated>2017-01-01T10:45:22.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是面向切面编程（AOP）"><a href="#1-什么是面向切面编程（AOP）" class="headerlink" title="1 什么是面向切面编程（AOP）"></a>1 什么是面向切面编程（AOP）</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先说一下<strong>横切关注点</strong>，散布于应用中多处的功能被成为横切关注点，往往会直接把横切关注点嵌入到应用的业务逻辑之中。而<strong>面向切面编程（AOP）</strong>的目的就是把这些横切关注点与业务逻辑相分离。</p>
<p><img src="https://wenka.github.io/pictures/2017010101.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，切面实现了横切关注点的模块化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用面向切面编程时，仍然需要在一个地方定义通用功能，但是可能通过声明的方式定义这个功能要以何种方式的何地使用，而无需修改受影响的类。横切关注点可以被模块化成特殊的类，这种类就是<strong>切面</strong>。</p>
<h1 id="2-AOP-中的名词"><a href="#2-AOP-中的名词" class="headerlink" title="2 AOP 中的名词"></a>2 AOP 中的名词</h1><h2 id="2-1-通知"><a href="#2-1-通知" class="headerlink" title="2.1 通知"></a>2.1 通知</h2><p><strong>通知</strong>定义了切面是什么以及何时使用。</p>
<p>Spring 切面的五种通知：</p>
<ul>
<li><strong>前置通知</strong>（Before）：在目标方法被调用之前调用该通知功能。</li>
<li><strong>后置通知</strong>（After）：在目标完成之后调用通知。并不关心方法的输出。</li>
<li><strong>返回通知</strong>（After-returning）：在目标方法成功执行之后调用通知。</li>
<li><strong>异常通知</strong>（After-throwing）：在目标方法抛出异常后调用用纸。</li>
<li><strong>环绕通知</strong>（Around）：通知包含了被通知的方法，在被通知的方法调用之前和调用之后执行自定义行为。</li>
</ul>
<h2 id="2-2-连接点"><a href="#2-2-连接点" class="headerlink" title="2.2 连接点"></a>2.2 连接点</h2><p><strong>连接点</strong>是在应用执行过程中能够插入切面的一个点。这个点可以调用方法时，抛出异常时，甚至修改一个字段时。</p>
<h2 id="2-3-切点"><a href="#2-3-切点" class="headerlink" title="2.3 切点"></a>2.3 切点</h2><p><strong>切点</strong>会匹配通知所有植入的一个或多个连接点。</p>
<h2 id="2-4-切面"><a href="#2-4-切面" class="headerlink" title="2.4 切面"></a>2.4 切面</h2><p><strong>切面</strong>通知和切点的结合。</p>
<h1 id="3-简单实例（使用注解方式）"><a href="#3-简单实例（使用注解方式）" class="headerlink" title="3 简单实例（使用注解方式）"></a>3 简单实例（使用注解方式）</h1><h2 id="3-1-创建带有简单加减乘除的接口及其实现类"><a href="#3-1-创建带有简单加减乘除的接口及其实现类" class="headerlink" title="3.1 创建带有简单加减乘除的接口及其实现类"></a>3.1 创建带有简单加减乘除的接口及其实现类</h2><pre><code>package com.spring.aop.helloworld;

public interface SimpleCalculator {

    double add(double num1, double num2);

    double sub(double num1, double num2);

    double mult(double num1, double num2);

    double div(double num1, double num2);

}
</code></pre><p>目标：调用每个方法的时候获取方法名及参数列表。</p>
<p>如果不面向切面编程，我们就需要在每个方法的前后加入同样的代码来获取参数列表等，会产生大量的冗余代码。使用切面，将这些冗余代码提取出来，单独放入一个类中，使用方法的业务与其它功能分开来，有利于代码的简洁，提高代码的重用性，方便了后期的维护。</p>
<h2 id="3-2-编写切面类"><a href="#3-2-编写切面类" class="headerlink" title="3.2 编写切面类"></a>3.2 编写切面类</h2><pre><code>@Component
@Aspect
public class LogginAspectj { ...... }
</code></pre><ul>
<li><strong>@Component</strong>：首先将该类放入 IOC 容器中。</li>
<li><strong>@Aspect</strong>：将此类声明为一个切面类。</li>
</ul>
<h2 id="3-3-编写通知"><a href="#3-3-编写通知" class="headerlink" title="3.3 编写通知"></a>3.3 编写通知</h2><pre><code>@Before(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;)
public void beforeMethod(JoinPoint joinPoint) {
    String name = joinPoint.getSignature().getName();
    List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());
    System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;);
}

// 后置通知
@After(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;)
public void afterMethod(JoinPoint joinPoint) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;);
}

// 返回通知
//在【方法正常结束】执行的代码
//返回通知是可以接受返回值的
@AfterReturning(value = &quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;, returning = &quot;result&quot;)
public void afterReturning(JoinPoint joinPoint, Object result) {
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result);
}

//异常通知
//在目标方法出现异常时会执行的代码
//可以访问到异常对象；且可以指定特定异常时再执行异常通知代码
@AfterThrowing(value = &quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;, throwing=&quot;e&quot;)
public void afterThrowing(JoinPoint joinPoint,Exception e){
    String methodName = joinPoint.getSignature().getName();
    System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e);
}
</code></pre><ol>
<li>声明通知方法<ul>
<li>@Before：前置通知</li>
<li>@After：后置通知</li>
<li>@Afterreturning：返回通知</li>
<li>@AfterThrowing：异常通知</li>
</ul>
</li>
<li>通知注解中的参数<ul>
<li>value 值：切面表达式。告知此通知的切点。<ul>
<li><strong>execution</strong>：在相关方法执行时触发。</li>
<li><ul>
<li>： 代表任意。第一个代表任意返回值，第二个代表com.spring.aop.helloworld.SimpleCalculator 此类下的任意方法。</li>
</ul>
</li>
<li><strong>(..)</strong>：代表使用任意参数。</li>
</ul>
</li>
<li>returning：@AfterReturning通知后的返回值。</li>
<li>throwing：@AfterThrowing通知获取到的异常。</li>
</ul>
</li>
<li>参数列表：    <ul>
<li>JoinPoint：连接点。通过连接点<strong>joinPoint.getSignature().getName()</strong>可以获取激活此通知的方法名。通过<strong>joinPoint.getArgs()</strong>获取激活此通知的方法的参数列表。</li>
<li>Object：与<strong>@AfterReturning</strong>中的属性<strong>returning</strong>名一致。获取激活此通知的方法的返回值。</li>
<li>Exception：与<strong>@AfterThrowing</strong>中的属性<strong>throwing</strong>名一致。获取激活此通知的方法的异常信息。</li>
</ul>
</li>
</ol>
<h2 id="3-4-通用的切点"><a href="#3-4-通用的切点" class="headerlink" title="3.4 通用的切点"></a>3.4 通用的切点</h2><p>以上代码会发现，每个通知中的切点都一样，那既然都一样的话，那会不会有一种简单的方式，使我们只用写一次切面表达式而达到重用呢？答案肯定有。</p>
<pre><code>//切面表达式
@Pointcut(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;)
public void declarExpression(){}
</code></pre><p>使用<strong>@Pointcut</strong>声明此方法为一个切点。这样的话，所有的切面表达式都只需要替换成此方法的方法名即可。这样就省去了重复写那么长那么多的切面表达式的力气。</p>
<pre><code>@Component
@Aspect
public class LogginAspectj {

    //切面表达式
    @Pointcut(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;)
    public void declarExpression(){}


    // 声明该方法是一个前置通知：在目标方法执行之前执行
    @Before(&quot;declarExpression()&quot;)
    public void beforeMethod(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());
        System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;);
    }

    // 后置通知
    @After(&quot;declarExpression()&quot;)
    public void afterMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;);
    }

    // 返回通知
    //在【方法正常结束】执行的代码
    //返回通知是可以接受返回值的
    @AfterReturning(value = &quot;declarExpression()&quot;, returning = &quot;result&quot;)
    public void afterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result);
    }

    //异常通知
    //在目标方法出现异常时会执行的代码
    //可以访问到异常对象；且可以指定特定异常时再执行异常通知代码
    @AfterThrowing(value = &quot;declarExpression()&quot;, throwing=&quot;e&quot;)
    public void afterThrowing(JoinPoint joinPoint,Exception e){
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e);
    }
}
</code></pre><h2 id="3-5-完结了吗？"><a href="#3-5-完结了吗？" class="headerlink" title="3.5 完结了吗？"></a>3.5 完结了吗？</h2><p>至此，此类仅仅是IOC中的一个普通bean，即使使用了@Aspect注解，但是它依旧不会被视为切面，这些注解不会被解析，也不会被转换为切面的代理。我们还有在<strong>Spring配置文件</strong>中加入<strong>Spring aop命名空间</strong>中的<strong><aop:aspectj-autoproxy></aop:aspectj-autoproxy></strong>元素。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;&gt;

    &lt;context:component-scan base-package=&quot;com.spring.aop.helloworld&quot;&gt;&lt;/context:component-scan&gt;

    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;

&lt;/beans&gt;
</code></pre><h2 id="3-6-环绕通知"><a href="#3-6-环绕通知" class="headerlink" title="3.6 环绕通知"></a>3.6 环绕通知</h2><p>环绕通知包括了以上的四种通知。因此单独拿出来。其类似于动态代理，先看代码：</p>
<pre><code>@Around(&quot;execution(* com.spring.aop.helloworld.SimpleCalculator.*(..))&quot;)
public Object aroundMethod(ProceedingJoinPoint pJoinPoint) {

    Object result = 0.0;

    String methodName = pJoinPoint.getSignature().getName();

    // 执行目标方法
    try {
        // 前置通知
        System.out.println(&quot;The Method &quot; + methodName + &quot; Begin with &quot; + Arrays.asList(pJoinPoint.getArgs()));
        result = pJoinPoint.proceed();
        // 返回通知
        System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result);
    } catch (Throwable e) {
        System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e);
    }
    //后置通知
    System.out.println(&quot;The Method &quot; + methodName + &quot; End&quot;);

    return result;
}
</code></pre><p>注意一下几点：</p>
<ol>
<li>环绕通知类似于<strong>动态代理</strong>的全过程：ProceedingJoinPoint 参数可以决定是否执行目标方法。</li>
<li>环绕通知必须有<strong>返回值</strong>，返回值即为目标方法的返回值。</li>
<li>环绕通知需要携带 <strong>ProceedingJoinPoint</strong> 类型的参数。通过此参数可以获取激活此通知的方法的相关信息。</li>
</ol>
<h1 id="4-简单实例（使用XML配置）"><a href="#4-简单实例（使用XML配置）" class="headerlink" title="4 简单实例（使用XML配置）"></a>4 简单实例（使用XML配置）</h1><h2 id="4-1-编写测试用例：接口与类"><a href="#4-1-编写测试用例：接口与类" class="headerlink" title="4.1 编写测试用例：接口与类"></a>4.1 编写测试用例：接口与类</h2><p>在此依旧使用上面的接口类。</p>
<p>需要改变的是切面类。去掉其中的所有注解，只是简单的JAVA类。我们将使用 XML 配置的方式一一配置。</p>
<pre><code>public class LogginAspectj {

    public void beforeMethod(JoinPoint joinPoint) {
        String name = joinPoint.getSignature().getName();
        List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());
        System.out.println(&quot;The &quot; + name + &quot; Method with &quot; + args + &quot; Begin!...&quot;);
    }

    public void afterMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; End!...&quot;);
    }

    public void afterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; End with &quot; + result);
    }

    public void afterThrowing(JoinPoint joinPoint, Exception e) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println(&quot;The Method &quot; + methodName + &quot; Exception with &quot; + e);
    }
}
</code></pre><h2 id="4-2-Spring-配置文件"><a href="#4-2-Spring-配置文件" class="headerlink" title="4.2 Spring 配置文件"></a>4.2 Spring 配置文件</h2><h3 id="4-2-1-配置-bean"><a href="#4-2-1-配置-bean" class="headerlink" title="4.2.1 配置 bean"></a>4.2.1 配置 bean</h3><pre><code>&lt;!-- 配置 bean --&gt;
&lt;bean id=&quot;simpleCalculator&quot; class=&quot;com.spring.aop.xml.SimpleCalculatorImpl&quot;&gt;&lt;/bean&gt;

&lt;!-- 配置切面 bean --&gt;
&lt;bean id=&quot;logginAspectj&quot; class=&quot;com.spring.aop.xml.LogginAspectj&quot;&gt;&lt;/bean&gt;
</code></pre><h3 id="4-2-2-配置-AOP"><a href="#4-2-2-配置-AOP" class="headerlink" title="4.2.2 配置 AOP"></a>4.2.2 配置 AOP</h3><pre><code>&lt;aop:config&gt;
    ......(4.2.3内容，4.2.4内容)
&lt;/aop:config&gt;
</code></pre><h3 id="4-2-3-配置切点表达式"><a href="#4-2-3-配置切点表达式" class="headerlink" title="4.2.3 配置切点表达式"></a>4.2.3 配置切点表达式</h3><pre><code>&lt;aop:pointcut
    expression=&quot;execution(* com.spring.aop.xml.SimpleCalculator.*(..))&quot;
    id=&quot;pointCut&quot; /&gt;
</code></pre><h3 id="4-2-4-配置切面及通知"><a href="#4-2-4-配置切面及通知" class="headerlink" title="4.2.4 配置切面及通知"></a>4.2.4 配置切面及通知</h3><pre><code>&lt;!-- ref:指定哪个 bean　为切面 --&gt;
&lt;aop:aspect ref=&quot;logginAspectj&quot;&gt;
    &lt;!-- 前置通知 --&gt; 
    &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointCut&quot; /&gt;
    &lt;!-- 后置通知 --&gt; 
    &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointCut&quot; /&gt;
    &lt;!-- 返回通知 --&gt; 
    &lt;aop:after-returning method=&quot;afterReturning&quot;
        pointcut-ref=&quot;pointCut&quot; returning=&quot;result&quot; /&gt;
    &lt;!-- 异常通知 --&gt; 
    &lt;aop:after-throwing method=&quot;afterThrowing&quot;
        pointcut-ref=&quot;pointCut&quot; throwing=&quot;e&quot; /&gt;
&lt;/aop:aspect&gt;
</code></pre><p>属性介绍：</p>
<ul>
<li>method：指定此通知的方法。</li>
<li>pointcut-ref：引用切点。</li>
<li>returning：返回值。要与方法中的名称一致。</li>
<li>throwing：异常。要与方法中的名称一致。</li>
</ul>
<h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h1><p><strong>面向切面编程（AOP）</strong>可以把分散在应用各处的相同的行为放入可重用的模块中，只需显式的声明此行为在何时何处使用。有效的减少了代码的冗余，使我们的类更多的关心自身的业务。</p>
<p><em>————(以上为个人理解请多指教)<br>2017/1/1 15:58:55 </em></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-什么是面向切面编程（AOP）&quot;&gt;&lt;a href=&quot;#1-什么是面向切面编程（AOP）&quot; class=&quot;headerlink&quot; title=&quot;1 什么是面向切面编程（AOP）&quot;&gt;&lt;/a&gt;1 什么是面向切面编程（AOP）&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;n
    
    </summary>
    
      <category term="Spring4" scheme="https://wenka.github.io/categories/Spring4/"/>
    
    
      <category term="MVC" scheme="https://wenka.github.io/tags/MVC/"/>
    
      <category term="AOP" scheme="https://wenka.github.io/tags/AOP/"/>
    
      <category term="面向切面编程" scheme="https://wenka.github.io/tags/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>backbone-helloword 入门简单实例</title>
    <link href="https://wenka.github.io/2016/12/30/backbone-helloword/"/>
    <id>https://wenka.github.io/2016/12/30/backbone-helloword/</id>
    <published>2016-12-30T06:48:24.000Z</published>
    <updated>2017-01-01T10:45:37.559Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Backbone-简介"><a href="#Backbone-简介" class="headerlink" title="Backbone 简介"></a>Backbone 简介</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js为复杂WEB应用程序提供模型(models)、集合(collections)、视图(views)的结构。其中模型用于绑定键值数据和自定义事件；集合附有可枚举函数的丰富API； 视图可以声明事件处理函数，并通过RESRful JSON接口连接到应用程序。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Backbone.js提供了一套web开发的框架，通过Models进行key-value绑定及custom事件处理,通过Collections提供一套丰富的API用于枚举功能,通过Views来进行事件处理及与现有的Application通过RESTful JSON接口进行交互.它是基于jquery和underscore的一个js框架。</p>
<p><strong>主要组成</strong></p>
<ul>
<li>Model：创建数据模型，进行数据验证、销毁或者保存。</li>
<li>collection：model 的集合类。可以增加元素，删除元素，获取长度，排序，比较等一系列工具方法。</li>
<li>view：绑定 html 模板，绑定页面元素的时间，初始的渲染，模型值改变后的重新渲染和界面元素的销毁等。</li>
<li>Router：是对路由的处理，就像传统网站通过url现实不同的页面，在单页面应用（SPA）中通过Router来控制前面说的View的展示。</li>
</ul>
<p>中文 API 网址：<a href="http://www.css88.com/doc/backbone/" target="_blank" rel="external">http://www.css88.com/doc/backbone/</a></p>
<p>Backbone 源码：<a href="https://github.com/jashkenas/backbone/" target="_blank" rel="external">https://github.com/jashkenas/backbone/</a></p>
<p>Backbone.js入门教程第二版：<a href="http://www.kancloud.cn/kancloud/backbonejs-learning-note" target="_blank" rel="external">http://www.kancloud.cn/kancloud/backbonejs-learning-note</a></p>
<p>underscore.js中文文档：<a href="http://www.css88.com/doc/underscore/" target="_blank" rel="external">http://www.css88.com/doc/underscore/</a></p>
<h1 id="HelloWorld-简单-Demo-实例"><a href="#HelloWorld-简单-Demo-实例" class="headerlink" title="HelloWorld 简单 Demo 实例"></a>HelloWorld 简单 Demo 实例</h1><h2 id="加入相关-JS"><a href="#加入相关-JS" class="headerlink" title="加入相关 JS"></a>加入相关 JS</h2><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;../jquery-1.8.3.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../underscore.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;../backbone.js&quot;&gt;&lt;/script&gt;
</code></pre><h3 id="JS-说明"><a href="#JS-说明" class="headerlink" title="JS 说明"></a>JS 说明</h3><ul>
<li>jquery-1.8.3.js：jQuery 相关，非必须。</li>
<li>underscore.js：Backbone 的唯一重度依赖 js。提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。</li>
<li>backbone.js：这个自然为 backbone 的核心 js。</li>
<li>js 加入顺序就按我的来就行。</li>
</ul>
<h2 id="js-代码"><a href="#js-代码" class="headerlink" title="js 代码"></a>js 代码</h2><pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
        $(function(){

            // 创建一个 World 模型
            var Word = Backbone.Model.extend({
                defaults:{
                    context:&quot;没什么想说的！&quot;
                }
            });

            //创建一个 World 集合
            var Words = Backbone.Collection.extend({
                modle:Word //指定集合中的 model 
            });

            var words = new Words;

            //创建整个 body 视图
            var AppView = Backbone.View.extend({
                el:$(&quot;body&quot;),

                events:{
                    &quot;click #say&quot;:&quot;say&quot; //为 id=&quot;say&quot; 的按钮绑定单击事件
                },

                //初始化
                initialize: function () {
                    this.input = $(&quot;#context&quot;);
                    //监听器  对 words 集合的 add 事件监听，回调函数 addWord
                    this.listenTo(words,&quot;add&quot;,this.addWord);
                },

                //对应上面 say
                say:function(){
                    var s = this.input.val();
                    var word; 
                    if (s == &quot;&quot;) {
                        word = new Word;
                    }else{
                        word = new Word({context:s});
                    }
                    words.add(word);
                    this.input.val(&quot;&quot;);
                },

                //对应上面的 addWord
                addWord:function(model){
                    $(&quot;#list&quot;).append(&quot;&lt;li&gt;&quot; + model.get(&quot;context&quot;) + &quot;&lt;/li&gt;&quot;);
                }
            });

            //创建视图实例
            var appView = new AppView;

        })
    &lt;/script&gt;
</code></pre><p>这个简单的 helloworld 实例，涉及到 Model、Collection、View，每发送一句话代表就创建一个 model，并将这句话加入 collection 集合中，“add” 事件触发 addWord 方法，在 id 为 list 的ul 中加入一个 li 标签。</p>
<h1 id="helloworld-结束语"><a href="#helloworld-结束语" class="headerlink" title="helloworld 结束语"></a>helloworld 结束语</h1><p>backbone 讲传统的 js mvc化，即模型、控制、视图分开开来，使前端与 server 的交互变得简单。有此优点：根据模型的变更自动更新应用程序的 HTML，有助于代码维护，同时促进客户端模块的使用，避免了在 JavaScript 中嵌套 Html 代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Backbone-简介&quot;&gt;&lt;a href=&quot;#Backbone-简介&quot; class=&quot;headerlink&quot; title=&quot;Backbone 简介&quot;&gt;&lt;/a&gt;Backbone 简介&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbs
    
    </summary>
    
      <category term="backbone" scheme="https://wenka.github.io/categories/backbone/"/>
    
    
      <category term="MVC" scheme="https://wenka.github.io/tags/MVC/"/>
    
      <category term="前端" scheme="https://wenka.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>苦行僧 Java 笔记之“单例”</title>
    <link href="https://wenka.github.io/2016/12/25/java_singleton/"/>
    <id>https://wenka.github.io/2016/12/25/java_singleton/</id>
    <published>2016-12-25T08:13:27.000Z</published>
    <updated>2017-01-01T10:45:49.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-单例"><a href="#Java-单例" class="headerlink" title="Java 单例"></a>Java 单例</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式应该算是 23 种设计模式中最简单的一种模式了。所谓“单例”：就是一个类只有一个实例。因此，单例模式有以下三个要素：</p>
<ol>
<li>私有构造方法</li>
<li>指向自己实例的私有静态引用</li>
<li>一个返回自己实例的公有方法。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单例模式根据对象实例化时机分为两种：<strong>饿汉式</strong>与<strong>懒汉式</strong>。饿汉式：类在加载时就实例化一个对象；懒汉式：使用时实例化。</p>
<h2 id="单例的实现"><a href="#单例的实现" class="headerlink" title="单例的实现"></a>单例的实现</h2><h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><pre><code>package com.wenka.singleton;

public class Person1 {

    private final static Person1 PERSON1 = new Person1();

    private Person1() {

    }

    public static Person1 getInstance() {
        return PERSON1;
    }
}
</code></pre><h3 id="懒汉式单例（一）"><a href="#懒汉式单例（一）" class="headerlink" title="懒汉式单例（一）"></a>懒汉式单例（一）</h3><pre><code>package com.wenka.singleton;

public class Person2 {

    private static Person2 person2;

    private Person2() {

    }

    public synchronized static Person2 getInstance() {
        if (person2 == null) {
            person2 = new Person2();
        }
        return person2;
    }
}
</code></pre><h4 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h4><p><strong>synchronized：</strong>将获取单例类实例的方法原子性、不可分割，有效避免了在多线程情况下出现创建不同对象的情况。</p>
<h3 id="懒汉式单例（二）"><a href="#懒汉式单例（二）" class="headerlink" title="懒汉式单例（二）"></a>懒汉式单例（二）</h3><pre><code>package com.wenka.singleton;

public class Person3 {

    private static Person3 person;

    private Person3() {

    }

    public static Person3 getInstance() {

        if (person == null) {
            synchronized (Person3.class) {
                if (person == null) {
                    person = new Person3();
                }
            }
        }

        return person;
    }
}
</code></pre><h4 id="简要说明-1"><a href="#简要说明-1" class="headerlink" title="简要说明"></a>简要说明</h4><p>相比第一种懒汉式单例的方法，此次将 synchronized 同步代码块放入方法内容，这样只有在第一次创建到单例对象的时候，才会获取对象锁。一旦单例对象存在，将不用再如（一）一般每次获取单例对象都要进行获取锁，释放锁，大大提高了运行效率。</p>
<h2 id="单例的优点"><a href="#单例的优点" class="headerlink" title="单例的优点"></a>单例的优点</h2><ul>
<li>在内存中只创建了一个对象，节省了内存空间。</li>
<li>避免了频繁的创建、销毁对象。</li>
<li>避免对共享资源的多重占用。</li>
<li>全局访问。</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>单例模式使用的场景：频繁的创建销毁对象，有状态的工具类对象。但是需要注意的是：不能使用反射创建单例对象，将会得到不同的对象。</p>
<p>本文源码：<a href="https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton" title="Java单例模式" target="_blank" rel="external">https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/singleton</a></p>
]]></content>
    
    <summary type="html">
    
      创建单例的三种方法。
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="单例" scheme="https://wenka.github.io/tags/%E5%8D%95%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>苦行僧 Java 笔记之“线程”</title>
    <link href="https://wenka.github.io/2016/12/24/java_thread/"/>
    <id>https://wenka.github.io/2016/12/24/java_thread/</id>
    <published>2016-12-24T09:26:41.000Z</published>
    <updated>2017-01-01T10:46:00.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程 是程序中的执行线程。Java 虚拟机允许应用程序并发地运行多个执行线程。每个线程都有一个优先级，高优先级线程的执行优先于低优先级线程。</p>
<p>创建新执行线程有两种方法：</p>
<ol>
<li><p>一种方法是将类声明为 Thread 的子类。该子类应重写 Thread 类的 run 方法。接下来可以分配并启动该子类的实例。</p>
</li>
<li><p>创建线程的另一种方法是声明实现 Runnable 接口的类。该类然后实现 run 方法。然后可以分配该类的实例，在创建 Thread 时作为一个参数来传递并启动。</p>
</li>
</ol>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="java-lang-Thread-类的构造方法"><a href="#java-lang-Thread-类的构造方法" class="headerlink" title="java.lang.Thread 类的构造方法"></a>java.lang.Thread 类的构造方法</h3><pre><code>Thread() //① 分配新的 Thread 对象
Thread(Runnable target)  //② 参数为：实现 Runnable 接口的类
Thread(Runnable target, String name)  //③ 如②，并为此线程命名。
Thread(String name) //如① ,并为线程命名。
</code></pre><h3 id="方法一：继承-Thread-类。"><a href="#方法一：继承-Thread-类。" class="headerlink" title="方法一：继承 Thread 类。"></a>方法一：继承 Thread 类。</h3><pre><code>class Thread1 extends Thread{
    @Override
    public void run() {
        for(int i = 0; i &lt; 10; i++){
            System.out.println(i + &quot; ---&gt;Thread&quot;);
        }
    }
}
</code></pre><p>线程启动：调用构造方法①</p>
<pre><code>Thread1 thread1 = new Thread1();
thread1.start();
</code></pre><h3 id="方法二：实现-Runnable-接口。"><a href="#方法二：实现-Runnable-接口。" class="headerlink" title="方法二：实现 Runnable 接口。"></a>方法二：实现 Runnable 接口。</h3><pre><code>class Target implements Runnable{

    @Override
    public void run() {
        for(int i = 0; i &lt; 10; i++){
            System.out.println(i + &quot; ---&gt;target&quot;);
        }
    }

}
</code></pre><p>线程启动：调用构造方法②</p>
<pre><code>Target target = new Target();
new Thread(target).start();
</code></pre><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><pre><code>Thread.currentThread()：获取当前线程
start()：启动线程
getName()：获取当前线程的名字
setName()：设置当前线程的名字
sleep()：睡眠。定时。
join()： 等待该线程终止。
</code></pre><h2 id="线程之间的通信（一）：生产者消费者问题"><a href="#线程之间的通信（一）：生产者消费者问题" class="headerlink" title="线程之间的通信（一）：生产者消费者问题"></a>线程之间的通信（一）：生产者消费者问题</h2><h3 id="问题表述"><a href="#问题表述" class="headerlink" title="问题表述"></a>问题表述</h3><p><strong>仓库类 Products</strong>： 描述仓库库存大小，及储存商品。</p>
<p><strong>线程 Producter</strong> 表示生产者：生产产品，并放入仓库中，每次生产一件商品。若商品数量达到仓库库存大小时，生产等待;若商品数量小于仓库库存时，则继续生产。</p>
<p><strong>线程 Consumer</strong> 表示消费者： 购买商品。每次购买一件商品。若库存为 0 时，停止购买，消费等待;若仓库存在商品，则继续购买。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><h4 id="声明仓库类"><a href="#声明仓库类" class="headerlink" title="声明仓库类"></a>声明仓库类</h4><pre><code>class Products{
    static int maxSize = 10;//仓库大小
    static Queue&lt;Integer&gt; products = new LinkedList&lt;Integer&gt;(); //产品队列
}
</code></pre><h4 id="生产者线程"><a href="#生产者线程" class="headerlink" title="生产者线程"></a>生产者线程</h4><pre><code>//生产者
class Producter extends Thread{

    @Override
    public void run() {
        int i = 0;
        while (true) {
            synchronized (Products.class) {

                while (Products.products.size() == Products.maxSize) {
                    System.out.println(&quot;仓库已经满了&quot;);
                    try {
                        Products.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;生产出来的产品编号：&quot; + i);
                Products.products.add(i);
                i++;
                Products.class.notifyAll();
            }
        }

    }
}
</code></pre><h4 id="消费者线程"><a href="#消费者线程" class="headerlink" title="消费者线程"></a>消费者线程</h4><pre><code>//消费者
class Consumer extends Thread{
    @Override
    public void run() {
        while (true) {
            synchronized (Products.class) {
                while (Products.products.isEmpty()) {
                    System.out.println(&quot;仓库为空&quot;);
                    try {
                        Products.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() +&quot;消费的产品编号 : &quot; + Products.products.remove()); 
                Products.class.notifyAll(); //唤醒生产者线程生产产品
            }
        }
    }
}
</code></pre><h4 id="测试-编写-Main-方法"><a href="#测试-编写-Main-方法" class="headerlink" title="测试 编写 Main 方法"></a>测试 编写 Main 方法</h4><pre><code>public class MainTest {
    public static void main(String[] args) {
        Producter producter = new Producter();
        Consumer consumer = new Consumer();

        producter.setName(&quot;Products-----&gt;&quot;);
        consumer.setName(&quot;Consumer-----&gt;&quot;);

        producter.start();
        consumer.start();
    }
}
</code></pre><h3 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h3><ul>
<li><p><strong>synchronized</strong> 关键字：<strong>同步代码块，原子操作</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized 来给对象和方法或者代码块加锁，当它为一个方法或者一个代码块加锁的时候，只能有一个线程执行这段代码。当两个并发线程访问同一个对象的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后，释放锁，才能执行该代码块。</p>
</li>
<li><p><strong>wait()</strong> 方法：<strong>线程等待</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前对象必须拥有此对象监视器。该线程发布对此监视器的所有权并等待，直到其他线程通过调用 notify 方法，或 notifyAll 方法通知在此对象的监视器上等待的线程醒来。然后该线程将等到重新获得对监视器的所有权后才能继续执行。 </p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于某一个参数的版本，实现中断和虚假唤醒是可能的，而且此方法应始终在<strong>循环</strong>中使用</p>
</li>
<li><p><strong>notifyAll()</strong> 方法：<strong>唤醒</strong></p>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唤醒在此对象监视器上等待的所有线程。直到当前线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。</p>
</li>
</ul>
<h2 id="线程之间的通信（二）：多线程顺序打印“ABC”"><a href="#线程之间的通信（二）：多线程顺序打印“ABC”" class="headerlink" title="线程之间的通信（二）：多线程顺序打印“ABC”"></a>线程之间的通信（二）：多线程顺序打印“ABC”</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><ol>
<li><p>线程A 负责打印“A”；</p>
</li>
<li><p>线程B 负责打印“B”；</p>
</li>
<li><p>线程C 负责打印“C”。</p>
</li>
</ol>
<h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><h4 id="公用类"><a href="#公用类" class="headerlink" title="公用类"></a>公用类</h4><pre><code>class PrintABC {

    static Integer flag = 1;

    static void printA() {
        System.out.println(&quot;A&quot;);
    }

    static void printB() {
        System.out.println(&quot;B&quot;);
    }

    static void printC() {
        System.out.println(&quot;C&quot;);
    }
}
</code></pre><h4 id="A线程"><a href="#A线程" class="headerlink" title="A线程"></a>A线程</h4><pre><code>// 打印 A
class ThreadA extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 1) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printA();
                PrintABC.flag = 2;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="B线程"><a href="#B线程" class="headerlink" title="B线程"></a>B线程</h4><pre><code>// 打印 B
class ThreadB extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 2) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printB();
                PrintABC.flag = 3;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="C线程"><a href="#C线程" class="headerlink" title="C线程"></a>C线程</h4><pre><code>//打印 C
class ThreadC extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            synchronized (PrintABC.class) {
                while (PrintABC.flag != 3) {
                    try {
                        PrintABC.class.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                PrintABC.printC();
                PrintABC.flag = 1;
                PrintABC.class.notifyAll();
            }
        }
    }
}
</code></pre><h4 id="测试-Main-方法"><a href="#测试-Main-方法" class="headerlink" title="测试 Main 方法"></a>测试 Main 方法</h4><pre><code>public class MainClass {
    public static void main(String[] args) {
        new ThreadA().start();
        new ThreadB().start();
        new ThreadC().start();
    }
}
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文对 Java 多线程的通信进行了简单的描述，欢迎对此文的补充。<br>代码：<a href="https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread" title="Java线程" target="_blank" rel="external">https://github.com/wenka/JavaHighDevelopment/tree/master/src/com/wenka/thread</a></p>
]]></content>
    
    <summary type="html">
    
      Java 线程的两个特殊例子：生产者消费者问题，线程通信顺序打印“ABC”
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="线程" scheme="https://wenka.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="https://wenka.github.io/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>苦行僧 Java 笔记之“反射”</title>
    <link href="https://wenka.github.io/2016/12/23/java_reflect/"/>
    <id>https://wenka.github.io/2016/12/23/java_reflect/</id>
    <published>2016-12-23T11:28:41.000Z</published>
    <updated>2017-01-01T10:46:05.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><h3 id="1、什么是反射？"><a href="#1、什么是反射？" class="headerlink" title="1、什么是反射？"></a>1、什么是反射？</h3><pre><code>JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。
</code></pre><h3 id="2、反射用来干什么？"><a href="#2、反射用来干什么？" class="headerlink" title="2、反射用来干什么？"></a>2、反射用来干什么？</h3><pre><code>判断任意一个对象所属的类；调用其构造方法构造类的实例；获取、操作任意一个类所具
有的成员变量和方法；在运行时调用任意一个对象的方法等。
</code></pre><a id="more"></a>
<h3 id="3、怎么用呢？"><a href="#3、怎么用呢？" class="headerlink" title="3、怎么用呢？"></a>3、怎么用呢？</h3><p>首先我们先创建一个普通的 Demo 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">package com.wenka.reflect;</div><div class="line">public class Demo &#123;</div><div class="line">	public Demo() &#123;</div><div class="line">	&#125;	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####3.1 获取 Class<br><strong>三种方式获取 Class 对象：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; demo1 = null;</div><div class="line">Class&lt;?&gt; demo2 = null;</div><div class="line">Class&lt;?&gt; demo3 = null;</div></pre></td></tr></table></figure>
<ul>
<li><strong>① 通过 Class 类的静态方法 forName(String className)，参数为需要获取 Class 的类的</strong>全类名<strong>。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo1 = Class.forName(&quot;com.wenka.reflect.Demo&quot;);</div></pre></td></tr></table></figure>
<p>注意：这里 ClassNotFoundException  异常需要处理，由于我们只是测试用，所以在这里选择上抛。</p>
<p>-<strong>② 从此类的实例中获取</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo2 = new Demo().getClass();</div></pre></td></tr></table></figure>
<p>-<strong>② 从类名中获取</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">demo3 = Demo.class;</div></pre></td></tr></table></figure>
<p>-<strong>输出结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">demo1：class com.wenka.reflect.Demo</div><div class="line">demo2：class com.wenka.reflect.Demo</div><div class="line">demo3：class com.wenka.reflect.Demo</div></pre></td></tr></table></figure>
<p>####3.2 获取到 Class 有什么用呢？？<br>相信对于初学者也如当初的我一样，不知道接下来能干什么？这时，我们看一下 JavaAPI：java.lang.Class&lt;<em>T</em>&gt; 这个类。没错，我们可以通过它获取各种方法、各种属性等。</p>
<ul>
<li><strong>① 在此之前先创建一个 Person 类方便测试</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package com.wenka.reflect;</div><div class="line"></div><div class="line">public class Person &#123;</div><div class="line"></div><div class="line">	//两个私有属性</div><div class="line">	private String name;</div><div class="line">	private Integer age;</div><div class="line"></div><div class="line">	//两个私有属性的 getter/setter 方法</div><div class="line">	public String getName() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setName(String name) &#123;</div><div class="line">		this.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Integer getAge() &#123;</div><div class="line">		return age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public void setAge(Integer age) &#123;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//重写 toString() 方法输出测试。</div><div class="line">	@Override</div><div class="line">	public String toString() &#123;</div><div class="line">		return &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//写了四个构造方法：一个两参的，一个public一参的，一个private一参的，一个无参的。</div><div class="line">	public Person(String name, Integer age) &#123;</div><div class="line">		super();</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Person(String name) &#123;</div><div class="line">		this(name, 20);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private Person(Integer age) &#123;</div><div class="line">		this(&quot;zhangsan&quot;, age);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public Person() &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//两个私有方法：有参 work(int hours)、 无参 salary()</div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private void work(int hours) &#123;</div><div class="line">		System.out.println(name + &quot;工作了&quot; + hours + &quot;个小时&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@SuppressWarnings(&quot;unused&quot;)</div><div class="line">	private double salary() &#123;</div><div class="line">		return 5000;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>② 获取构造方法</strong></p>
<ul>
<li><p>获取 Class</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Class&lt;?&gt; demo = Class.forName(&quot;com.wenka.reflect.Person&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>- 通过 API 发现有两个获取所有构造参数的方法。
</code></pre><p><strong>getConstructors()</strong> 和 <strong>getDeclaredConstructors()</strong><br>通过对比发现：getConstructors()：不能获取到类的私有构造方法，而 getDeclaredConstructors() 则可以获取到所有的构造方法。</p>
<pre><code>- 获取到指定的构造方法：
- getConstructor(Class&lt;*?*&gt;... parameterTypes) 和 getConstructor(Class&lt;*?*&gt;... parameterTypes) 
</code></pre><p>参数列表为想要的获取的那个构造方法所对应的参数列表<br>楼主在此获取得到 public 参数列表为 String 的构造方法。通过调用 Constructor&lt;<em>T</em>&gt; 中的 newInstance(Object… initargs)  方法创建实例。此方法的参数列表就是对应的构造方法的参数列表的实参。</p>
<pre><code>    `Person person = 
    (Person) demo.getConstructor(String.class).newInstance(&quot;wangwu&quot;);
    `
- 在此就有了疑问，既然我们可以通过 getDeclaredConstructor(Class&lt;*?*&gt;... parameterTypes) 获取到 **私有**的方法，那我们是不是也能通过此种办法，使得我们可以利用私有**构造方法**来创建实例？

 `Constructor&lt;?&gt; constructor = demo.getDeclaredConstructor(Integer.class);`

 没错，我们通过此方法获取到了私有构造方法，但是我们直接通过此创建实例会有异常：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">java.lang.IllegalAccessException: Class com.wenka.reflect.MainClass can not access a member of class com.wenka.reflect.Person with modifiers &quot;private&quot;</div></pre></td></tr></table></figure>

意思是说：这个构造方法是 “private”的，我们不能访问。但是，不要灰心，自习看了一下 Constructor&lt;*T*&gt; 类，Field、Method 和 Constructor 对象的基类为 **AccessibleObject** 类，这个类是干什么呢？
**它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。**哦，原来这个类可以取消 Java 语言的访问控制检查的能力啊。这就好办了。我们讲刚得到的私有构造方法
</code></pre><p>调用 setAccessible(boolean flag) 方法。将此方法设置为 false，使其取消反射的对象实施 Java 语言访问检查。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">constructor.setAccessible(true);</div></pre></td></tr></table></figure>



到此：


    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Object newInstance = constructor.newInstance(20);</div><div class="line">System.out.println(newInstance);</div></pre></td></tr></table></figure>


输出：

    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person [name=zhangsan, age=20]</div></pre></td></tr></table></figure>


如果只能通过无参的构造方法来创建实例就比较简单了：当然前提是一定要有无参构造。

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = (Person) Demo.newInstance();</div><div class="line">			person.setAge(20);</div><div class="line">			person.setName(&quot;A&quot;);</div><div class="line">			System.out.println(person);</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p><strong>③ 获取字段</strong></p>
<ul>
<li>获取所有字段，与获取构造方法类似。调用 <strong>getDeclaredFields()</strong> 或者 <strong>getFields() </strong></li>
<li><p>获取指定字段并赋值。<strong>getDeclaredField(String name) </strong>参数：字段名。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Field field = demo.getDeclaredField(&quot;age&quot;);</div><div class="line">field.setAccessible(true);</div></pre></td></tr></table></figure>
<p>  为字段设置新值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Person person = new Person(&quot;AAAAAA&quot;);</div><div class="line">//field.set(obj, value);给 obj 对象的此属性设置 value 新值</div><div class="line">field.set(person, 100);</div><div class="line">System.out.println(person)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>④ 获取方法</strong></p>
<ul>
<li>获取所有方法：<strong>getMethods()</strong>和 <strong>getDeclaredMethods();</strong></li>
<li><p>获取指定的方法：（在此依旧是获取 private 的方法，其它方法类似。）</p>
<ul>
<li>当初我们创建的实体类中有 两个私有方法：有参 work(int hours)、 无参 salary()</li>
</ul>
<p><strong>getDeclaredMethod(String name, Class&lt;<em>?</em>&gt;… parameterTypes)</strong>：参数列表为：1.方法名，2. 对应方法的参数列表的类型，0个 或者 多个。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Method work = demo.getDeclaredMethod(&quot;work&quot;, int.class);</div><div class="line">			System.out.println(work);</div><div class="line">work.setAccessible(true);</div><div class="line">Person person = new Person(&quot;AAAA&quot;);</div><div class="line">// invoke(Object obj, Object... args) </div><div class="line">work.invoke(person, 10);</div></pre></td></tr></table></figure>
<p> 输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">private void com.wenka.reflect.Person.work(int)</div><div class="line">AAAA工作了10个小时</div></pre></td></tr></table></figure>
<p>Method 类中的 <strong>invoke(Object obj, Object… args)</strong> 方法，<strong>对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。</strong> 参数：1.指定对象 2.对应参数列表的实参。</p>
<ul>
<li><p>倘若方法有返回值，则直接返回：</p>
<p><code>Method salary = demo.getDeclaredMethod(&quot;salary&quot;);
   salary.setAccessible(true);
   Object invoke = salary.invoke(person);
   System.out.println(&quot;得到了工资：&quot; + invoke);</code></p>
</li>
</ul>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">得到了工资：5000.0</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>致此：反射的简单用法都已经写完了，可以发现，反射很强大的，我们甚至可以通过反射使 单例 不再单例，通过反射获取注释，接口等关于此类的所有信息，并从底层操作。未来学习的框架都运用了反射的原理来实现。</p>
]]></content>
    
    <summary type="html">
    
      JAVA 反射机制是在运行状态中，对与一个类或者对象，都能获取并操作它所有的属性和方法。
    
    </summary>
    
      <category term="Java" scheme="https://wenka.github.io/categories/Java/"/>
    
    
      <category term="反射" scheme="https://wenka.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wenka.github.io/2016/12/21/hello-world/"/>
    <id>https://wenka.github.io/2016/12/21/hello-world/</id>
    <published>2016-12-21T14:41:19.830Z</published>
    <updated>2016-12-24T01:47:02.815Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
